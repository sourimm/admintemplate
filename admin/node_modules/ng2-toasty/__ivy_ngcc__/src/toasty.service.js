// Copyright (C) 2016-2017 Sergey Akopkokhyants
// This project is licensed under the terms of the MIT license.
// https://github.com/akserg/ng2-toasty
import { Injectable } from '@angular/core';
import { isString, isNumber, isFunction } from './toasty.utils';
import { Subject } from 'rxjs/Subject';
/**
 * Options to configure specific Toast
 */
import * as ɵngcc0 from '@angular/core';
var ToastOptions = (function () {
    function ToastOptions() {
    }
    /** @nocollapse */
    ToastOptions.ctorParameters = function () { return []; };
ToastOptions.ɵfac = function ToastOptions_Factory(t) { return new (t || ToastOptions)(); };
ToastOptions.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ToastOptions, factory: function (t) { return ToastOptions.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ToastOptions, [{
        type: Injectable
    }], function () { return []; }, null); })();
    return ToastOptions;
}());
export { ToastOptions };
/**
 * Structrure of Toast
 */
var ToastData = (function () {
    function ToastData() {
    }
    /** @nocollapse */
    ToastData.ctorParameters = function () { return []; };
ToastData.ɵfac = function ToastData_Factory(t) { return new (t || ToastData)(); };
ToastData.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ToastData, factory: function (t) { return ToastData.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ToastData, [{
        type: Injectable
    }], function () { return []; }, null); })();
    return ToastData;
}());
export { ToastData };
/**
 * Default configuration foa all toats and toasty container
 */
var ToastyConfig = (function () {
    function ToastyConfig() {
        // Maximum number of toasties to show at once
        this.limit = 5;
        // Whether to show the 'X' icon to close the toast
        this.showClose = true;
        // The window position where the toast pops up
        this.position = 'bottom-right';
        // How long (in miliseconds) the toasty shows before it's removed. Set to null/0 to turn off.
        this.timeout = 5000;
        // What theme to use
        this.theme = 'default';
    }
    /** @nocollapse */
    ToastyConfig.ctorParameters = function () { return []; };
ToastyConfig.ɵfac = function ToastyConfig_Factory(t) { return new (t || ToastyConfig)(); };
ToastyConfig.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ToastyConfig, factory: function (t) { return ToastyConfig.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ToastyConfig, [{
        type: Injectable
    }], function () { return []; }, null); })();
    return ToastyConfig;
}());
export { ToastyConfig };
export var ToastyEventType;
(function (ToastyEventType) {
    ToastyEventType[ToastyEventType["ADD"] = 0] = "ADD";
    ToastyEventType[ToastyEventType["CLEAR"] = 1] = "CLEAR";
    ToastyEventType[ToastyEventType["CLEAR_ALL"] = 2] = "CLEAR_ALL";
})(ToastyEventType || (ToastyEventType = {}));
var ToastyEvent = (function () {
    function ToastyEvent(type, value) {
        this.type = type;
        this.value = value;
    }
    return ToastyEvent;
}());
export { ToastyEvent };
export function toastyServiceFactory(config) {
    return new ToastyService(config);
}
/**
 * Toasty service helps create different kinds of Toasts
 */
var ToastyService = (function () {
    function ToastyService(config) {
        this.config = config;
        // Init the counter
        this.uniqueCounter = 0;
        // ToastData event emitter
        // private toastsEmitter: EventEmitter<ToastData> = new EventEmitter<ToastData>();
        // Clear event emitter
        // private clearEmitter: EventEmitter<number> = new EventEmitter<number>();
        this.eventSource = new Subject();
        this.events = this.eventSource.asObservable();
    }
    /**
     * Get list of toats
     */
    // getToasts(): Observable<ToastData> {
    //   return this.toastsEmitter.asObservable();
    // }
    // getClear(): Observable<number> {
    //   return this.clearEmitter.asObservable();
    // }
    /**
     * Create Toast of a default type
     */
    ToastyService.prototype.default = function (options) {
        this.add(options, 'default');
    };
    /**
     * Create Toast of info type
     * @param  {object} options Individual toasty config overrides
     */
    ToastyService.prototype.info = function (options) {
        this.add(options, 'info');
    };
    /**
     * Create Toast of success type
     * @param  {object} options Individual toasty config overrides
     */
    ToastyService.prototype.success = function (options) {
        this.add(options, 'success');
    };
    /**
     * Create Toast of wait type
     * @param  {object} options Individual toasty config overrides
     */
    ToastyService.prototype.wait = function (options) {
        this.add(options, 'wait');
    };
    /**
     * Create Toast of error type
     * @param  {object} options Individual toasty config overrides
     */
    ToastyService.prototype.error = function (options) {
        this.add(options, 'error');
    };
    /**
     * Create Toast of warning type
     * @param  {object} options Individual toasty config overrides
     */
    ToastyService.prototype.warning = function (options) {
        this.add(options, 'warning');
    };
    // Add a new toast item
    ToastyService.prototype.add = function (options, type) {
        var toastyOptions;
        if (isString(options) && options !== '' || isNumber(options)) {
            toastyOptions = {
                title: options.toString()
            };
        }
        else {
            toastyOptions = options;
        }
        if (!toastyOptions || !toastyOptions.title && !toastyOptions.msg) {
            throw new Error('ng2-toasty: No toast title or message specified!');
        }
        type = type || 'default';
        // Set a unique counter for an id
        this.uniqueCounter++;
        // Set the local vs global config items
        var showClose = this._checkConfigItem(this.config, toastyOptions, 'showClose');
        // If we have a theme set, make sure it's a valid one
        var theme;
        if (toastyOptions.theme) {
            theme = ToastyService.THEMES.indexOf(toastyOptions.theme) > -1 ? toastyOptions.theme : this.config.theme;
        }
        else {
            theme = this.config.theme;
        }
        var toast = {
            id: this.uniqueCounter,
            title: toastyOptions.title,
            msg: toastyOptions.msg,
            showClose: showClose,
            type: 'toasty-type-' + type,
            theme: 'toasty-theme-' + theme,
            onAdd: toastyOptions.onAdd && isFunction(toastyOptions.onAdd) ? toastyOptions.onAdd : null,
            onRemove: toastyOptions.onRemove && isFunction(toastyOptions.onRemove) ? toastyOptions.onRemove : null
        };
        // If there's a timeout individually or globally, set the toast to timeout
        // Allows a caller to pass null/0 and override the default. Can also set the default to null/0 to turn off.
        toast.timeout = toastyOptions.hasOwnProperty('timeout') ? toastyOptions.timeout : this.config.timeout;
        // Push up a new toast item
        // this.toastsSubscriber.next(toast);
        // this.toastsEmitter.next(toast);
        this.emitEvent(new ToastyEvent(ToastyEventType.ADD, toast));
        // If we have a onAdd function, call it here
        if (toastyOptions.onAdd && isFunction(toastyOptions.onAdd)) {
            toastyOptions.onAdd.call(this, toast);
        }
    };
    // Clear all toasts
    ToastyService.prototype.clearAll = function () {
        // this.clearEmitter.next(null);
        this.emitEvent(new ToastyEvent(ToastyEventType.CLEAR_ALL));
    };
    // Clear the specific one
    ToastyService.prototype.clear = function (id) {
        // this.clearEmitter.next(id);
        this.emitEvent(new ToastyEvent(ToastyEventType.CLEAR, id));
    };
    // Checks whether the local option is set, if not,
    // checks the global config
    ToastyService.prototype._checkConfigItem = function (config, options, property) {
        if (options[property] === false) {
            return false;
        }
        else if (!options[property]) {
            return config[property];
        }
        else {
            return true;
        }
    };
    ToastyService.prototype.emitEvent = function (event) {
        if (this.eventSource) {
            // Push up a new event
            this.eventSource.next(event);
        }
    };
    // Allowed THEMES
    ToastyService.THEMES = ['default', 'material', 'bootstrap'];
    /** @nocollapse */
    ToastyService.ctorParameters = function () { return [
        { type: ToastyConfig, },
    ]; };
ToastyService.ɵfac = function ToastyService_Factory(t) { return new (t || ToastyService)(ɵngcc0.ɵɵinject(ToastyConfig)); };
ToastyService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ToastyService, factory: function (t) { return ToastyService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ToastyService, [{
        type: Injectable
    }], function () { return [{ type: ToastyConfig }]; }, null); })();
    return ToastyService;
}());
export { ToastyService };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9hc3R5LnNlcnZpY2UuanMiLCJzb3VyY2VzIjpbInRvYXN0eS5zZXJ2aWNlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0EsS0FHTTtBQUNOO0FBQ0E7Ozs7O2dEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FHTTtBQUNOO0FBQ0E7Ozs7O2dEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUdNO0FBQ047QUFDQTs7Ozs7Z0RBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFHTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOzs7OztzRUFBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoQykgMjAxNi0yMDE3IFNlcmdleSBBa29wa29raHlhbnRzXG4vLyBUaGlzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNSVQgbGljZW5zZS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ha3NlcmcvbmcyLXRvYXN0eVxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgaXNTdHJpbmcsIGlzTnVtYmVyLCBpc0Z1bmN0aW9uIH0gZnJvbSAnLi90b2FzdHkudXRpbHMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG4vKipcbiAqIE9wdGlvbnMgdG8gY29uZmlndXJlIHNwZWNpZmljIFRvYXN0XG4gKi9cbnZhciBUb2FzdE9wdGlvbnMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRvYXN0T3B0aW9ucygpIHtcbiAgICB9XG4gICAgVG9hc3RPcHRpb25zLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgVG9hc3RPcHRpb25zLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgcmV0dXJuIFRvYXN0T3B0aW9ucztcbn0oKSk7XG5leHBvcnQgeyBUb2FzdE9wdGlvbnMgfTtcbi8qKlxuICogU3RydWN0cnVyZSBvZiBUb2FzdFxuICovXG52YXIgVG9hc3REYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb2FzdERhdGEoKSB7XG4gICAgfVxuICAgIFRvYXN0RGF0YS5kZWNvcmF0b3JzID0gW1xuICAgICAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbiAgICBdO1xuICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgIFRvYXN0RGF0YS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIHJldHVybiBUb2FzdERhdGE7XG59KCkpO1xuZXhwb3J0IHsgVG9hc3REYXRhIH07XG4vKipcbiAqIERlZmF1bHQgY29uZmlndXJhdGlvbiBmb2EgYWxsIHRvYXRzIGFuZCB0b2FzdHkgY29udGFpbmVyXG4gKi9cbnZhciBUb2FzdHlDb25maWcgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRvYXN0eUNvbmZpZygpIHtcbiAgICAgICAgLy8gTWF4aW11bSBudW1iZXIgb2YgdG9hc3RpZXMgdG8gc2hvdyBhdCBvbmNlXG4gICAgICAgIHRoaXMubGltaXQgPSA1O1xuICAgICAgICAvLyBXaGV0aGVyIHRvIHNob3cgdGhlICdYJyBpY29uIHRvIGNsb3NlIHRoZSB0b2FzdFxuICAgICAgICB0aGlzLnNob3dDbG9zZSA9IHRydWU7XG4gICAgICAgIC8vIFRoZSB3aW5kb3cgcG9zaXRpb24gd2hlcmUgdGhlIHRvYXN0IHBvcHMgdXBcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9ICdib3R0b20tcmlnaHQnO1xuICAgICAgICAvLyBIb3cgbG9uZyAoaW4gbWlsaXNlY29uZHMpIHRoZSB0b2FzdHkgc2hvd3MgYmVmb3JlIGl0J3MgcmVtb3ZlZC4gU2V0IHRvIG51bGwvMCB0byB0dXJuIG9mZi5cbiAgICAgICAgdGhpcy50aW1lb3V0ID0gNTAwMDtcbiAgICAgICAgLy8gV2hhdCB0aGVtZSB0byB1c2VcbiAgICAgICAgdGhpcy50aGVtZSA9ICdkZWZhdWx0JztcbiAgICB9XG4gICAgVG9hc3R5Q29uZmlnLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgVG9hc3R5Q29uZmlnLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgcmV0dXJuIFRvYXN0eUNvbmZpZztcbn0oKSk7XG5leHBvcnQgeyBUb2FzdHlDb25maWcgfTtcbmV4cG9ydCB2YXIgVG9hc3R5RXZlbnRUeXBlO1xuKGZ1bmN0aW9uIChUb2FzdHlFdmVudFR5cGUpIHtcbiAgICBUb2FzdHlFdmVudFR5cGVbVG9hc3R5RXZlbnRUeXBlW1wiQUREXCJdID0gMF0gPSBcIkFERFwiO1xuICAgIFRvYXN0eUV2ZW50VHlwZVtUb2FzdHlFdmVudFR5cGVbXCJDTEVBUlwiXSA9IDFdID0gXCJDTEVBUlwiO1xuICAgIFRvYXN0eUV2ZW50VHlwZVtUb2FzdHlFdmVudFR5cGVbXCJDTEVBUl9BTExcIl0gPSAyXSA9IFwiQ0xFQVJfQUxMXCI7XG59KShUb2FzdHlFdmVudFR5cGUgfHwgKFRvYXN0eUV2ZW50VHlwZSA9IHt9KSk7XG52YXIgVG9hc3R5RXZlbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRvYXN0eUV2ZW50KHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIFRvYXN0eUV2ZW50O1xufSgpKTtcbmV4cG9ydCB7IFRvYXN0eUV2ZW50IH07XG5leHBvcnQgZnVuY3Rpb24gdG9hc3R5U2VydmljZUZhY3RvcnkoY29uZmlnKSB7XG4gICAgcmV0dXJuIG5ldyBUb2FzdHlTZXJ2aWNlKGNvbmZpZyk7XG59XG4vKipcbiAqIFRvYXN0eSBzZXJ2aWNlIGhlbHBzIGNyZWF0ZSBkaWZmZXJlbnQga2luZHMgb2YgVG9hc3RzXG4gKi9cbnZhciBUb2FzdHlTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb2FzdHlTZXJ2aWNlKGNvbmZpZykge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgLy8gSW5pdCB0aGUgY291bnRlclxuICAgICAgICB0aGlzLnVuaXF1ZUNvdW50ZXIgPSAwO1xuICAgICAgICAvLyBUb2FzdERhdGEgZXZlbnQgZW1pdHRlclxuICAgICAgICAvLyBwcml2YXRlIHRvYXN0c0VtaXR0ZXI6IEV2ZW50RW1pdHRlcjxUb2FzdERhdGE+ID0gbmV3IEV2ZW50RW1pdHRlcjxUb2FzdERhdGE+KCk7XG4gICAgICAgIC8vIENsZWFyIGV2ZW50IGVtaXR0ZXJcbiAgICAgICAgLy8gcHJpdmF0ZSBjbGVhckVtaXR0ZXI6IEV2ZW50RW1pdHRlcjxudW1iZXI+ID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG4gICAgICAgIHRoaXMuZXZlbnRTb3VyY2UgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IHRoaXMuZXZlbnRTb3VyY2UuYXNPYnNlcnZhYmxlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBsaXN0IG9mIHRvYXRzXG4gICAgICovXG4gICAgLy8gZ2V0VG9hc3RzKCk6IE9ic2VydmFibGU8VG9hc3REYXRhPiB7XG4gICAgLy8gICByZXR1cm4gdGhpcy50b2FzdHNFbWl0dGVyLmFzT2JzZXJ2YWJsZSgpO1xuICAgIC8vIH1cbiAgICAvLyBnZXRDbGVhcigpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xuICAgIC8vICAgcmV0dXJuIHRoaXMuY2xlYXJFbWl0dGVyLmFzT2JzZXJ2YWJsZSgpO1xuICAgIC8vIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgVG9hc3Qgb2YgYSBkZWZhdWx0IHR5cGVcbiAgICAgKi9cbiAgICBUb2FzdHlTZXJ2aWNlLnByb3RvdHlwZS5kZWZhdWx0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hZGQob3B0aW9ucywgJ2RlZmF1bHQnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBUb2FzdCBvZiBpbmZvIHR5cGVcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IG9wdGlvbnMgSW5kaXZpZHVhbCB0b2FzdHkgY29uZmlnIG92ZXJyaWRlc1xuICAgICAqL1xuICAgIFRvYXN0eVNlcnZpY2UucHJvdG90eXBlLmluZm8gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmFkZChvcHRpb25zLCAnaW5mbycpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIFRvYXN0IG9mIHN1Y2Nlc3MgdHlwZVxuICAgICAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9ucyBJbmRpdmlkdWFsIHRvYXN0eSBjb25maWcgb3ZlcnJpZGVzXG4gICAgICovXG4gICAgVG9hc3R5U2VydmljZS5wcm90b3R5cGUuc3VjY2VzcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYWRkKG9wdGlvbnMsICdzdWNjZXNzJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgVG9hc3Qgb2Ygd2FpdCB0eXBlXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBvcHRpb25zIEluZGl2aWR1YWwgdG9hc3R5IGNvbmZpZyBvdmVycmlkZXNcbiAgICAgKi9cbiAgICBUb2FzdHlTZXJ2aWNlLnByb3RvdHlwZS53YWl0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hZGQob3B0aW9ucywgJ3dhaXQnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBUb2FzdCBvZiBlcnJvciB0eXBlXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSBvcHRpb25zIEluZGl2aWR1YWwgdG9hc3R5IGNvbmZpZyBvdmVycmlkZXNcbiAgICAgKi9cbiAgICBUb2FzdHlTZXJ2aWNlLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYWRkKG9wdGlvbnMsICdlcnJvcicpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIFRvYXN0IG9mIHdhcm5pbmcgdHlwZVxuICAgICAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9ucyBJbmRpdmlkdWFsIHRvYXN0eSBjb25maWcgb3ZlcnJpZGVzXG4gICAgICovXG4gICAgVG9hc3R5U2VydmljZS5wcm90b3R5cGUud2FybmluZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYWRkKG9wdGlvbnMsICd3YXJuaW5nJyk7XG4gICAgfTtcbiAgICAvLyBBZGQgYSBuZXcgdG9hc3QgaXRlbVxuICAgIFRvYXN0eVNlcnZpY2UucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChvcHRpb25zLCB0eXBlKSB7XG4gICAgICAgIHZhciB0b2FzdHlPcHRpb25zO1xuICAgICAgICBpZiAoaXNTdHJpbmcob3B0aW9ucykgJiYgb3B0aW9ucyAhPT0gJycgfHwgaXNOdW1iZXIob3B0aW9ucykpIHtcbiAgICAgICAgICAgIHRvYXN0eU9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IG9wdGlvbnMudG9TdHJpbmcoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRvYXN0eU9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdG9hc3R5T3B0aW9ucyB8fCAhdG9hc3R5T3B0aW9ucy50aXRsZSAmJiAhdG9hc3R5T3B0aW9ucy5tc2cpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbmcyLXRvYXN0eTogTm8gdG9hc3QgdGl0bGUgb3IgbWVzc2FnZSBzcGVjaWZpZWQhJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHlwZSA9IHR5cGUgfHwgJ2RlZmF1bHQnO1xuICAgICAgICAvLyBTZXQgYSB1bmlxdWUgY291bnRlciBmb3IgYW4gaWRcbiAgICAgICAgdGhpcy51bmlxdWVDb3VudGVyKys7XG4gICAgICAgIC8vIFNldCB0aGUgbG9jYWwgdnMgZ2xvYmFsIGNvbmZpZyBpdGVtc1xuICAgICAgICB2YXIgc2hvd0Nsb3NlID0gdGhpcy5fY2hlY2tDb25maWdJdGVtKHRoaXMuY29uZmlnLCB0b2FzdHlPcHRpb25zLCAnc2hvd0Nsb3NlJyk7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSB0aGVtZSBzZXQsIG1ha2Ugc3VyZSBpdCdzIGEgdmFsaWQgb25lXG4gICAgICAgIHZhciB0aGVtZTtcbiAgICAgICAgaWYgKHRvYXN0eU9wdGlvbnMudGhlbWUpIHtcbiAgICAgICAgICAgIHRoZW1lID0gVG9hc3R5U2VydmljZS5USEVNRVMuaW5kZXhPZih0b2FzdHlPcHRpb25zLnRoZW1lKSA+IC0xID8gdG9hc3R5T3B0aW9ucy50aGVtZSA6IHRoaXMuY29uZmlnLnRoZW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhlbWUgPSB0aGlzLmNvbmZpZy50aGVtZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG9hc3QgPSB7XG4gICAgICAgICAgICBpZDogdGhpcy51bmlxdWVDb3VudGVyLFxuICAgICAgICAgICAgdGl0bGU6IHRvYXN0eU9wdGlvbnMudGl0bGUsXG4gICAgICAgICAgICBtc2c6IHRvYXN0eU9wdGlvbnMubXNnLFxuICAgICAgICAgICAgc2hvd0Nsb3NlOiBzaG93Q2xvc2UsXG4gICAgICAgICAgICB0eXBlOiAndG9hc3R5LXR5cGUtJyArIHR5cGUsXG4gICAgICAgICAgICB0aGVtZTogJ3RvYXN0eS10aGVtZS0nICsgdGhlbWUsXG4gICAgICAgICAgICBvbkFkZDogdG9hc3R5T3B0aW9ucy5vbkFkZCAmJiBpc0Z1bmN0aW9uKHRvYXN0eU9wdGlvbnMub25BZGQpID8gdG9hc3R5T3B0aW9ucy5vbkFkZCA6IG51bGwsXG4gICAgICAgICAgICBvblJlbW92ZTogdG9hc3R5T3B0aW9ucy5vblJlbW92ZSAmJiBpc0Z1bmN0aW9uKHRvYXN0eU9wdGlvbnMub25SZW1vdmUpID8gdG9hc3R5T3B0aW9ucy5vblJlbW92ZSA6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBhIHRpbWVvdXQgaW5kaXZpZHVhbGx5IG9yIGdsb2JhbGx5LCBzZXQgdGhlIHRvYXN0IHRvIHRpbWVvdXRcbiAgICAgICAgLy8gQWxsb3dzIGEgY2FsbGVyIHRvIHBhc3MgbnVsbC8wIGFuZCBvdmVycmlkZSB0aGUgZGVmYXVsdC4gQ2FuIGFsc28gc2V0IHRoZSBkZWZhdWx0IHRvIG51bGwvMCB0byB0dXJuIG9mZi5cbiAgICAgICAgdG9hc3QudGltZW91dCA9IHRvYXN0eU9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3RpbWVvdXQnKSA/IHRvYXN0eU9wdGlvbnMudGltZW91dCA6IHRoaXMuY29uZmlnLnRpbWVvdXQ7XG4gICAgICAgIC8vIFB1c2ggdXAgYSBuZXcgdG9hc3QgaXRlbVxuICAgICAgICAvLyB0aGlzLnRvYXN0c1N1YnNjcmliZXIubmV4dCh0b2FzdCk7XG4gICAgICAgIC8vIHRoaXMudG9hc3RzRW1pdHRlci5uZXh0KHRvYXN0KTtcbiAgICAgICAgdGhpcy5lbWl0RXZlbnQobmV3IFRvYXN0eUV2ZW50KFRvYXN0eUV2ZW50VHlwZS5BREQsIHRvYXN0KSk7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBvbkFkZCBmdW5jdGlvbiwgY2FsbCBpdCBoZXJlXG4gICAgICAgIGlmICh0b2FzdHlPcHRpb25zLm9uQWRkICYmIGlzRnVuY3Rpb24odG9hc3R5T3B0aW9ucy5vbkFkZCkpIHtcbiAgICAgICAgICAgIHRvYXN0eU9wdGlvbnMub25BZGQuY2FsbCh0aGlzLCB0b2FzdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIENsZWFyIGFsbCB0b2FzdHNcbiAgICBUb2FzdHlTZXJ2aWNlLnByb3RvdHlwZS5jbGVhckFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdGhpcy5jbGVhckVtaXR0ZXIubmV4dChudWxsKTtcbiAgICAgICAgdGhpcy5lbWl0RXZlbnQobmV3IFRvYXN0eUV2ZW50KFRvYXN0eUV2ZW50VHlwZS5DTEVBUl9BTEwpKTtcbiAgICB9O1xuICAgIC8vIENsZWFyIHRoZSBzcGVjaWZpYyBvbmVcbiAgICBUb2FzdHlTZXJ2aWNlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAvLyB0aGlzLmNsZWFyRW1pdHRlci5uZXh0KGlkKTtcbiAgICAgICAgdGhpcy5lbWl0RXZlbnQobmV3IFRvYXN0eUV2ZW50KFRvYXN0eUV2ZW50VHlwZS5DTEVBUiwgaWQpKTtcbiAgICB9O1xuICAgIC8vIENoZWNrcyB3aGV0aGVyIHRoZSBsb2NhbCBvcHRpb24gaXMgc2V0LCBpZiBub3QsXG4gICAgLy8gY2hlY2tzIHRoZSBnbG9iYWwgY29uZmlnXG4gICAgVG9hc3R5U2VydmljZS5wcm90b3R5cGUuX2NoZWNrQ29uZmlnSXRlbSA9IGZ1bmN0aW9uIChjb25maWcsIG9wdGlvbnMsIHByb3BlcnR5KSB7XG4gICAgICAgIGlmIChvcHRpb25zW3Byb3BlcnR5XSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghb3B0aW9uc1twcm9wZXJ0eV0pIHtcbiAgICAgICAgICAgIHJldHVybiBjb25maWdbcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvYXN0eVNlcnZpY2UucHJvdG90eXBlLmVtaXRFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5ldmVudFNvdXJjZSkge1xuICAgICAgICAgICAgLy8gUHVzaCB1cCBhIG5ldyBldmVudFxuICAgICAgICAgICAgdGhpcy5ldmVudFNvdXJjZS5uZXh0KGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQWxsb3dlZCBUSEVNRVNcbiAgICBUb2FzdHlTZXJ2aWNlLlRIRU1FUyA9IFsnZGVmYXVsdCcsICdtYXRlcmlhbCcsICdib290c3RyYXAnXTtcbiAgICBUb2FzdHlTZXJ2aWNlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgVG9hc3R5U2VydmljZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgeyB0eXBlOiBUb2FzdHlDb25maWcsIH0sXG4gICAgXTsgfTtcbiAgICByZXR1cm4gVG9hc3R5U2VydmljZTtcbn0oKSk7XG5leHBvcnQgeyBUb2FzdHlTZXJ2aWNlIH07XG4iXX0=