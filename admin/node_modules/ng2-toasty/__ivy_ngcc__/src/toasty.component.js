// Copyright (C) 2016-2017 Sergey Akopkokhyants
// This project is licensed under the terms of the MIT license.
// https://github.com/akserg/ng2-toasty
import { Component, Input } from '@angular/core';
import { isFunction } from './toasty.utils';
import { ToastyService, ToastyConfig, ToastyEventType } from './toasty.service';
/**
 * Toasty is container for Toast components
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './toasty.service';
import * as ɵngcc2 from '@angular/common';
import * as ɵngcc3 from './toast.component';

function ToastyComponent_ng2_toast_1_Template(rf, ctx) { if (rf & 1) {
    var _r3 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "ng2-toast", 2);
    ɵngcc0.ɵɵlistener("closeToast", function ToastyComponent_ng2_toast_1_Template_ng2_toast_closeToast_0_listener() { ɵngcc0.ɵɵrestoreView(_r3); var toast_r1 = ctx.$implicit; var ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2.closeToast(toast_r1); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    var toast_r1 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("toast", toast_r1);
} }
var _c0 = function (a0) { return [a0]; };
var ToastyComponent = (function () {
    function ToastyComponent(config, toastyService) {
        this.config = config;
        this.toastyService = toastyService;
        this._position = '';
        // The storage for toasts.
        this.toasts = [];
        // Initialise position
        this.position = '';
    }
    Object.defineProperty(ToastyComponent.prototype, "position", {
        get: function () {
            return this._position;
        },
        // The window position where the toast pops up. Possible values:
        // - bottom-right (default value from ToastConfig)
        // - bottom-left
        // - top-right
        // - top-left
        // - top-center
        // - bottom-center
        // - center-center
        set: function (value) {
            if (value) {
                var notFound = true;
                for (var i = 0; i < ToastyComponent.POSITIONS.length; i++) {
                    if (ToastyComponent.POSITIONS[i] === value) {
                        notFound = false;
                        break;
                    }
                }
                if (notFound) {
                    // Position was wrong - clear it here to use the one from config.
                    value = this.config.position;
                }
            }
            else {
                value = this.config.position;
            }
            this._position = 'toasty-position-' + value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * `ngOnInit` is called right after the directive's data-bound properties have been checked for the
     * first time, and before any of its children have been checked. It is invoked only once when the
     * directive is instantiated.
     */
    ToastyComponent.prototype.ngOnInit = function () {
        var _this = this;
        // We listen events from our service
        this.toastyService.events.subscribe(function (event) {
            if (event.type === ToastyEventType.ADD) {
                // Add the new one
                var toast = event.value;
                _this.add(toast);
            }
            else if (event.type === ToastyEventType.CLEAR) {
                // Clear the one by number
                var id = event.value;
                _this.clear(id);
            }
            else if (event.type === ToastyEventType.CLEAR_ALL) {
                // Lets clear all toasts
                _this.clearAll();
            }
        });
    };
    /**
     * Event listener of 'closeToast' event comes from ToastyComponent.
     * This method removes ToastComponent assosiated with this Toast.
     */
    ToastyComponent.prototype.closeToast = function (toast) {
        this.clear(toast.id);
    };
    /**
     * Add new Toast
     */
    ToastyComponent.prototype.add = function (toast) {
        // If we've gone over our limit, remove the earliest
        // one from the array
        if (this.toasts.length >= this.config.limit) {
            this.toasts.shift();
        }
        // Add toasty to array
        this.toasts.push(toast);
        //
        // If there's a timeout individually or globally,
        // set the toast to timeout
        if (toast.timeout) {
            this._setTimeout(toast);
        }
    };
    /**
     * Clear individual toast by id
     * @param id is unique identifier of Toast
     */
    ToastyComponent.prototype.clear = function (id) {
        var _this = this;
        if (id) {
            this.toasts.forEach(function (value, key) {
                if (value.id === id) {
                    if (value.onRemove && isFunction(value.onRemove)) {
                        value.onRemove.call(_this, value);
                    }
                    _this.toasts.splice(key, 1);
                }
            });
        }
        else {
            throw new Error('Please provide id of Toast to close');
        }
    };
    /**
     * Clear all toasts
     */
    ToastyComponent.prototype.clearAll = function () {
        var _this = this;
        this.toasts.forEach(function (value, key) {
            if (value.onRemove && isFunction(value.onRemove)) {
                value.onRemove.call(_this, value);
            }
        });
        this.toasts = [];
    };
    /**
     * Custom setTimeout function for specific setTimeouts on individual toasts.
     */
    ToastyComponent.prototype._setTimeout = function (toast) {
        var _this = this;
        window.setTimeout(function () {
            _this.clear(toast.id);
        }, toast.timeout);
    };
    /**
     * Set of constants defins position of Toasty on the page.
     */
    ToastyComponent.POSITIONS = ['bottom-right', 'bottom-left', 'top-right', 'top-left', 'top-center', 'bottom-center', 'center-center'];
    /** @nocollapse */
    ToastyComponent.ctorParameters = function () { return [
        { type: ToastyConfig, },
        { type: ToastyService, },
    ]; };
    ToastyComponent.propDecorators = {
        'position': [{ type: Input },],
    };
ToastyComponent.ɵfac = function ToastyComponent_Factory(t) { return new (t || ToastyComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ToastyConfig), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ToastyService)); };
ToastyComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ToastyComponent, selectors: [["ng2-toasty"]], inputs: { position: "position" }, decls: 2, vars: 4, consts: [["id", "toasty", 3, "ngClass"], [3, "toast", "closeToast", 4, "ngFor", "ngForOf"], [3, "toast", "closeToast"]], template: function ToastyComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, ToastyComponent_ng2_toast_1_Template, 1, 1, "ng2-toast", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(2, _c0, ctx.position));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.toasts);
    } }, directives: [ɵngcc2.NgClass, ɵngcc2.NgForOf, ɵngcc3.ToastComponent], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ToastyComponent, [{
        type: Component,
        args: [{
                selector: 'ng2-toasty',
                template: "\n    <div id=\"toasty\" [ngClass]=\"[position]\">\n        <ng2-toast *ngFor=\"let toast of toasts\" [toast]=\"toast\" (closeToast)=\"closeToast(toast)\"></ng2-toast>\n    </div>"
            }]
    }], function () { return [{ type: ɵngcc1.ToastyConfig }, { type: ɵngcc1.ToastyService }]; }, { position: [{
            type: Input
        }] }); })();
    return ToastyComponent;
}());
export { ToastyComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9hc3R5LmNvbXBvbmVudC5qcyIsInNvdXJjZXMiOlsidG9hc3R5LmNvbXBvbmVudC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5SUFNTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQU07QUFDTjtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKEMpIDIwMTYtMjAxNyBTZXJnZXkgQWtvcGtva2h5YW50c1xuLy8gVGhpcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTUlUIGxpY2Vuc2UuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYWtzZXJnL25nMi10b2FzdHlcbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuL3RvYXN0eS51dGlscyc7XG5pbXBvcnQgeyBUb2FzdHlTZXJ2aWNlLCBUb2FzdHlDb25maWcsIFRvYXN0eUV2ZW50VHlwZSB9IGZyb20gJy4vdG9hc3R5LnNlcnZpY2UnO1xuLyoqXG4gKiBUb2FzdHkgaXMgY29udGFpbmVyIGZvciBUb2FzdCBjb21wb25lbnRzXG4gKi9cbnZhciBUb2FzdHlDb21wb25lbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRvYXN0eUNvbXBvbmVudChjb25maWcsIHRvYXN0eVNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMudG9hc3R5U2VydmljZSA9IHRvYXN0eVNlcnZpY2U7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gJyc7XG4gICAgICAgIC8vIFRoZSBzdG9yYWdlIGZvciB0b2FzdHMuXG4gICAgICAgIHRoaXMudG9hc3RzID0gW107XG4gICAgICAgIC8vIEluaXRpYWxpc2UgcG9zaXRpb25cbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9ICcnO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVG9hc3R5Q29tcG9uZW50LnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uO1xuICAgICAgICB9LFxuICAgICAgICAvLyBUaGUgd2luZG93IHBvc2l0aW9uIHdoZXJlIHRoZSB0b2FzdCBwb3BzIHVwLiBQb3NzaWJsZSB2YWx1ZXM6XG4gICAgICAgIC8vIC0gYm90dG9tLXJpZ2h0IChkZWZhdWx0IHZhbHVlIGZyb20gVG9hc3RDb25maWcpXG4gICAgICAgIC8vIC0gYm90dG9tLWxlZnRcbiAgICAgICAgLy8gLSB0b3AtcmlnaHRcbiAgICAgICAgLy8gLSB0b3AtbGVmdFxuICAgICAgICAvLyAtIHRvcC1jZW50ZXJcbiAgICAgICAgLy8gLSBib3R0b20tY2VudGVyXG4gICAgICAgIC8vIC0gY2VudGVyLWNlbnRlclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vdEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFRvYXN0eUNvbXBvbmVudC5QT1NJVElPTlMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFRvYXN0eUNvbXBvbmVudC5QT1NJVElPTlNbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vdEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBvc2l0aW9uIHdhcyB3cm9uZyAtIGNsZWFyIGl0IGhlcmUgdG8gdXNlIHRoZSBvbmUgZnJvbSBjb25maWcuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5jb25maWcucG9zaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmNvbmZpZy5wb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gJ3RvYXN0eS1wb3NpdGlvbi0nICsgdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIGBuZ09uSW5pdGAgaXMgY2FsbGVkIHJpZ2h0IGFmdGVyIHRoZSBkaXJlY3RpdmUncyBkYXRhLWJvdW5kIHByb3BlcnRpZXMgaGF2ZSBiZWVuIGNoZWNrZWQgZm9yIHRoZVxuICAgICAqIGZpcnN0IHRpbWUsIGFuZCBiZWZvcmUgYW55IG9mIGl0cyBjaGlsZHJlbiBoYXZlIGJlZW4gY2hlY2tlZC4gSXQgaXMgaW52b2tlZCBvbmx5IG9uY2Ugd2hlbiB0aGVcbiAgICAgKiBkaXJlY3RpdmUgaXMgaW5zdGFudGlhdGVkLlxuICAgICAqL1xuICAgIFRvYXN0eUNvbXBvbmVudC5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFdlIGxpc3RlbiBldmVudHMgZnJvbSBvdXIgc2VydmljZVxuICAgICAgICB0aGlzLnRvYXN0eVNlcnZpY2UuZXZlbnRzLnN1YnNjcmliZShmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSBUb2FzdHlFdmVudFR5cGUuQUREKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBuZXcgb25lXG4gICAgICAgICAgICAgICAgdmFyIHRvYXN0ID0gZXZlbnQudmFsdWU7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWRkKHRvYXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09IFRvYXN0eUV2ZW50VHlwZS5DTEVBUikge1xuICAgICAgICAgICAgICAgIC8vIENsZWFyIHRoZSBvbmUgYnkgbnVtYmVyXG4gICAgICAgICAgICAgICAgdmFyIGlkID0gZXZlbnQudmFsdWU7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2xlYXIoaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gVG9hc3R5RXZlbnRUeXBlLkNMRUFSX0FMTCkge1xuICAgICAgICAgICAgICAgIC8vIExldHMgY2xlYXIgYWxsIHRvYXN0c1xuICAgICAgICAgICAgICAgIF90aGlzLmNsZWFyQWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRXZlbnQgbGlzdGVuZXIgb2YgJ2Nsb3NlVG9hc3QnIGV2ZW50IGNvbWVzIGZyb20gVG9hc3R5Q29tcG9uZW50LlxuICAgICAqIFRoaXMgbWV0aG9kIHJlbW92ZXMgVG9hc3RDb21wb25lbnQgYXNzb3NpYXRlZCB3aXRoIHRoaXMgVG9hc3QuXG4gICAgICovXG4gICAgVG9hc3R5Q29tcG9uZW50LnByb3RvdHlwZS5jbG9zZVRvYXN0ID0gZnVuY3Rpb24gKHRvYXN0KSB7XG4gICAgICAgIHRoaXMuY2xlYXIodG9hc3QuaWQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIG5ldyBUb2FzdFxuICAgICAqL1xuICAgIFRvYXN0eUNvbXBvbmVudC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHRvYXN0KSB7XG4gICAgICAgIC8vIElmIHdlJ3ZlIGdvbmUgb3ZlciBvdXIgbGltaXQsIHJlbW92ZSB0aGUgZWFybGllc3RcbiAgICAgICAgLy8gb25lIGZyb20gdGhlIGFycmF5XG4gICAgICAgIGlmICh0aGlzLnRvYXN0cy5sZW5ndGggPj0gdGhpcy5jb25maWcubGltaXQpIHtcbiAgICAgICAgICAgIHRoaXMudG9hc3RzLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRvYXN0eSB0byBhcnJheVxuICAgICAgICB0aGlzLnRvYXN0cy5wdXNoKHRvYXN0KTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgdGhlcmUncyBhIHRpbWVvdXQgaW5kaXZpZHVhbGx5IG9yIGdsb2JhbGx5LFxuICAgICAgICAvLyBzZXQgdGhlIHRvYXN0IHRvIHRpbWVvdXRcbiAgICAgICAgaWYgKHRvYXN0LnRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFRpbWVvdXQodG9hc3QpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhciBpbmRpdmlkdWFsIHRvYXN0IGJ5IGlkXG4gICAgICogQHBhcmFtIGlkIGlzIHVuaXF1ZSBpZGVudGlmaWVyIG9mIFRvYXN0XG4gICAgICovXG4gICAgVG9hc3R5Q29tcG9uZW50LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIHRoaXMudG9hc3RzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5vblJlbW92ZSAmJiBpc0Z1bmN0aW9uKHZhbHVlLm9uUmVtb3ZlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUub25SZW1vdmUuY2FsbChfdGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRvYXN0cy5zcGxpY2Uoa2V5LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgaWQgb2YgVG9hc3QgdG8gY2xvc2UnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xlYXIgYWxsIHRvYXN0c1xuICAgICAqL1xuICAgIFRvYXN0eUNvbXBvbmVudC5wcm90b3R5cGUuY2xlYXJBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudG9hc3RzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5vblJlbW92ZSAmJiBpc0Z1bmN0aW9uKHZhbHVlLm9uUmVtb3ZlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlLm9uUmVtb3ZlLmNhbGwoX3RoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9hc3RzID0gW107XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDdXN0b20gc2V0VGltZW91dCBmdW5jdGlvbiBmb3Igc3BlY2lmaWMgc2V0VGltZW91dHMgb24gaW5kaXZpZHVhbCB0b2FzdHMuXG4gICAgICovXG4gICAgVG9hc3R5Q29tcG9uZW50LnByb3RvdHlwZS5fc2V0VGltZW91dCA9IGZ1bmN0aW9uICh0b2FzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5jbGVhcih0b2FzdC5pZCk7XG4gICAgICAgIH0sIHRvYXN0LnRpbWVvdXQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IG9mIGNvbnN0YW50cyBkZWZpbnMgcG9zaXRpb24gb2YgVG9hc3R5IG9uIHRoZSBwYWdlLlxuICAgICAqL1xuICAgIFRvYXN0eUNvbXBvbmVudC5QT1NJVElPTlMgPSBbJ2JvdHRvbS1yaWdodCcsICdib3R0b20tbGVmdCcsICd0b3AtcmlnaHQnLCAndG9wLWxlZnQnLCAndG9wLWNlbnRlcicsICdib3R0b20tY2VudGVyJywgJ2NlbnRlci1jZW50ZXInXTtcbiAgICBUb2FzdHlDb21wb25lbnQuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgeyB0eXBlOiBDb21wb25lbnQsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmcyLXRvYXN0eScsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8ZGl2IGlkPVxcXCJ0b2FzdHlcXFwiIFtuZ0NsYXNzXT1cXFwiW3Bvc2l0aW9uXVxcXCI+XFxuICAgICAgICA8bmcyLXRvYXN0ICpuZ0Zvcj1cXFwibGV0IHRvYXN0IG9mIHRvYXN0c1xcXCIgW3RvYXN0XT1cXFwidG9hc3RcXFwiIChjbG9zZVRvYXN0KT1cXFwiY2xvc2VUb2FzdCh0b2FzdClcXFwiPjwvbmcyLXRvYXN0PlxcbiAgICA8L2Rpdj5cIlxuICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgIF07XG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgVG9hc3R5Q29tcG9uZW50LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICB7IHR5cGU6IFRvYXN0eUNvbmZpZywgfSxcbiAgICAgICAgeyB0eXBlOiBUb2FzdHlTZXJ2aWNlLCB9LFxuICAgIF07IH07XG4gICAgVG9hc3R5Q29tcG9uZW50LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAncG9zaXRpb24nOiBbeyB0eXBlOiBJbnB1dCB9LF0sXG4gICAgfTtcbiAgICByZXR1cm4gVG9hc3R5Q29tcG9uZW50O1xufSgpKTtcbmV4cG9ydCB7IFRvYXN0eUNvbXBvbmVudCB9O1xuIl19