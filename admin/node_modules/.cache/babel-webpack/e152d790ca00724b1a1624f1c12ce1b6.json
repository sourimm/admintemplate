{"ast":null,"code":"import _get from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Subscription } from '../Subscription';\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n/**\n * Buffers the source Observable values, using a factory function of closing\n * Observables to determine when to close, emit, and reset the buffer.\n *\n * <span class=\"informal\">Collects values from the past as an array. When it\n * starts collecting values, it calls a function that returns an Observable that\n * tells when to close the buffer and restart collecting.</span>\n *\n * <img src=\"./img/bufferWhen.png\" width=\"100%\">\n *\n * Opens a buffer immediately, then closes the buffer when the observable\n * returned by calling `closingSelector` function emits a value. When it closes\n * the buffer, it immediately opens a new buffer and repeats the process.\n *\n * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferWhen(() =>\n *   Rx.Observable.interval(1000 + Math.random() * 4000)\n * );\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link windowWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals buffer closure.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferWhen\n * @owner Observable\n */\n\nexport function bufferWhen(closingSelector) {\n  return function (source) {\n    return source.lift(new BufferWhenOperator(closingSelector));\n  };\n}\n\nvar BufferWhenOperator = /*#__PURE__*/function () {\n  function BufferWhenOperator(closingSelector) {\n    _classCallCheck(this, BufferWhenOperator);\n\n    this.closingSelector = closingSelector;\n  }\n\n  _createClass(BufferWhenOperator, [{\n    key: \"call\",\n    value: function call(subscriber, source) {\n      return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));\n    }\n  }]);\n\n  return BufferWhenOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar BufferWhenSubscriber = /*#__PURE__*/function (_OuterSubscriber) {\n  _inherits(BufferWhenSubscriber, _OuterSubscriber);\n\n  var _super = _createSuper(BufferWhenSubscriber);\n\n  function BufferWhenSubscriber(destination, closingSelector) {\n    var _this;\n\n    _classCallCheck(this, BufferWhenSubscriber);\n\n    _this = _super.call(this, destination);\n    _this.closingSelector = closingSelector;\n    _this.subscribing = false;\n\n    _this.openBuffer();\n\n    return _this;\n  }\n\n  _createClass(BufferWhenSubscriber, [{\n    key: \"_next\",\n    value: function _next(value) {\n      this.buffer.push(value);\n    }\n  }, {\n    key: \"_complete\",\n    value: function _complete() {\n      var buffer = this.buffer;\n\n      if (buffer) {\n        this.destination.next(buffer);\n      }\n\n      _get(_getPrototypeOf(BufferWhenSubscriber.prototype), \"_complete\", this).call(this);\n    }\n    /** @deprecated This is an internal implementation detail, do not use. */\n\n  }, {\n    key: \"_unsubscribe\",\n    value: function _unsubscribe() {\n      this.buffer = null;\n      this.subscribing = false;\n    }\n  }, {\n    key: \"notifyNext\",\n    value: function notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n      this.openBuffer();\n    }\n  }, {\n    key: \"notifyComplete\",\n    value: function notifyComplete() {\n      if (this.subscribing) {\n        this.complete();\n      } else {\n        this.openBuffer();\n      }\n    }\n  }, {\n    key: \"openBuffer\",\n    value: function openBuffer() {\n      var closingSubscription = this.closingSubscription;\n\n      if (closingSubscription) {\n        this.remove(closingSubscription);\n        closingSubscription.unsubscribe();\n      }\n\n      var buffer = this.buffer;\n\n      if (this.buffer) {\n        this.destination.next(buffer);\n      }\n\n      this.buffer = [];\n      var closingNotifier = tryCatch(this.closingSelector)();\n\n      if (closingNotifier === errorObject) {\n        this.error(errorObject.e);\n      } else {\n        closingSubscription = new Subscription();\n        this.closingSubscription = closingSubscription;\n        this.add(closingSubscription);\n        this.subscribing = true;\n        closingSubscription.add(subscribeToResult(this, closingNotifier));\n        this.subscribing = false;\n      }\n    }\n  }]);\n\n  return BufferWhenSubscriber;\n}(OuterSubscriber);","map":{"version":3,"sources":["../../../src/internal/operators/bufferWhen.ts"],"names":[],"mappings":";;;;;;AAGA,SAAS,YAAT,QAA6B,iBAA7B;AACA,SAAS,QAAT,QAAyB,kBAAzB;AACA,SAAS,WAAT,QAA4B,qBAA5B;AACA,SAAS,eAAT,QAAgC,oBAAhC;AAEA,SAAS,iBAAT,QAAkC,2BAAlC;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA,OAAM,SAAA,UAAA,CAAwB,eAAxB,EAA8D;AAClE,SAAO,UAAU,MAAV,EAA+B;AACpC,WAAO,MAAM,CAAC,IAAP,CAAY,IAAI,kBAAJ,CAAuB,eAAvB,CAAZ,CAAP;AACD,GAFD;AAGD;;IAED,kB;AAEE,8BAAoB,eAApB,EAA0D;AAAA;;AAAtC,SAAA,eAAA,GAAA,eAAA;AACnB;;;;yBAEI,U,EAA6B,M,EAAW;AAC3C,aAAO,MAAM,CAAC,SAAP,CAAiB,IAAI,oBAAJ,CAAyB,UAAzB,EAAqC,KAAK,eAA1C,CAAjB,CAAP;AACD;;;;;AAGH;;;;;;;IAKA,oB;;;;;AAKE,gCAAY,WAAZ,EAAkD,eAAlD,EAAwF;AAAA;;AAAA;;AACtF,8BAAM,WAAN;AADgD,UAAA,eAAA,GAAA,eAAA;AAH1C,UAAA,WAAA,GAAuB,KAAvB;;AAKN,UAAK,UAAL;;AAFsF;AAGvF;;;;0BAEe,K,EAAQ;AACtB,WAAK,MAAL,CAAY,IAAZ,CAAiB,KAAjB;AACD;;;gCAEkB;AACjB,UAAM,MAAM,GAAG,KAAK,MAApB;;AACA,UAAI,MAAJ,EAAY;AACV,aAAK,WAAL,CAAiB,IAAjB,CAAsB,MAAtB;AACD;;AACD;AACD;AAED;;;;mCACY;AACV,WAAK,MAAL,GAAc,IAAd;AACA,WAAK,WAAL,GAAmB,KAAnB;AACD;;;+BAEU,U,EAAe,U,EACf,U,EAAoB,U,EACpB,Q,EAAiC;AAC1C,WAAK,UAAL;AACD;;;qCAEa;AACZ,UAAI,KAAK,WAAT,EAAsB;AACpB,aAAK,QAAL;AACD,OAFD,MAEO;AACL,aAAK,UAAL;AACD;AACF;;;iCAES;AAAA,UAEF,mBAFE,GAEsB,IAFtB,CAEF,mBAFE;;AAIR,UAAI,mBAAJ,EAAyB;AACvB,aAAK,MAAL,CAAY,mBAAZ;AACA,QAAA,mBAAmB,CAAC,WAApB;AACD;;AAED,UAAM,MAAM,GAAG,KAAK,MAApB;;AACA,UAAI,KAAK,MAAT,EAAiB;AACf,aAAK,WAAL,CAAiB,IAAjB,CAAsB,MAAtB;AACD;;AAED,WAAK,MAAL,GAAc,EAAd;AAEA,UAAM,eAAe,GAAG,QAAQ,CAAC,KAAK,eAAN,CAAR,EAAxB;;AAEA,UAAI,eAAe,KAAK,WAAxB,EAAqC;AACnC,aAAK,KAAL,CAAW,WAAW,CAAC,CAAvB;AACD,OAFD,MAEO;AACL,QAAA,mBAAmB,GAAG,IAAI,YAAJ,EAAtB;AACA,aAAK,mBAAL,GAA2B,mBAA3B;AACA,aAAK,GAAL,CAAS,mBAAT;AACA,aAAK,WAAL,GAAmB,IAAnB;AACA,QAAA,mBAAmB,CAAC,GAApB,CAAwB,iBAAiB,CAAC,IAAD,EAAO,eAAP,CAAzC;AACA,aAAK,WAAL,GAAmB,KAAnB;AACD;AACF;;;;EAtEmC,e","sourcesContent":["import { Subscription } from '../Subscription';\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n/**\n * Buffers the source Observable values, using a factory function of closing\n * Observables to determine when to close, emit, and reset the buffer.\n *\n * <span class=\"informal\">Collects values from the past as an array. When it\n * starts collecting values, it calls a function that returns an Observable that\n * tells when to close the buffer and restart collecting.</span>\n *\n * <img src=\"./img/bufferWhen.png\" width=\"100%\">\n *\n * Opens a buffer immediately, then closes the buffer when the observable\n * returned by calling `closingSelector` function emits a value. When it closes\n * the buffer, it immediately opens a new buffer and repeats the process.\n *\n * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferWhen(() =>\n *   Rx.Observable.interval(1000 + Math.random() * 4000)\n * );\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link windowWhen}\n *\n * @param {function(): Observable} closingSelector A function that takes no\n * arguments and returns an Observable that signals buffer closure.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferWhen\n * @owner Observable\n */\nexport function bufferWhen(closingSelector) {\n    return function (source) {\n        return source.lift(new BufferWhenOperator(closingSelector));\n    };\n}\nclass BufferWhenOperator {\n    constructor(closingSelector) {\n        this.closingSelector = closingSelector;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));\n    }\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferWhenSubscriber extends OuterSubscriber {\n    constructor(destination, closingSelector) {\n        super(destination);\n        this.closingSelector = closingSelector;\n        this.subscribing = false;\n        this.openBuffer();\n    }\n    _next(value) {\n        this.buffer.push(value);\n    }\n    _complete() {\n        const buffer = this.buffer;\n        if (buffer) {\n            this.destination.next(buffer);\n        }\n        super._complete();\n    }\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _unsubscribe() {\n        this.buffer = null;\n        this.subscribing = false;\n    }\n    notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.openBuffer();\n    }\n    notifyComplete() {\n        if (this.subscribing) {\n            this.complete();\n        }\n        else {\n            this.openBuffer();\n        }\n    }\n    openBuffer() {\n        let { closingSubscription } = this;\n        if (closingSubscription) {\n            this.remove(closingSubscription);\n            closingSubscription.unsubscribe();\n        }\n        const buffer = this.buffer;\n        if (this.buffer) {\n            this.destination.next(buffer);\n        }\n        this.buffer = [];\n        const closingNotifier = tryCatch(this.closingSelector)();\n        if (closingNotifier === errorObject) {\n            this.error(errorObject.e);\n        }\n        else {\n            closingSubscription = new Subscription();\n            this.closingSubscription = closingSubscription;\n            this.add(closingSubscription);\n            this.subscribing = true;\n            closingSubscription.add(subscribeToResult(this, closingNotifier));\n            this.subscribing = false;\n        }\n    }\n}\n//# sourceMappingURL=bufferWhen.js.map"]},"metadata":{},"sourceType":"module"}