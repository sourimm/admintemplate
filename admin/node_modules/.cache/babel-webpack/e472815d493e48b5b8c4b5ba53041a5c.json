{"ast":null,"code":"import _assertThisInitialized from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Subscriber } from '../Subscriber';\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\n/**\n * Compares all values of two observables in sequence using an optional comparor function\n * and returns an observable of a single boolean value representing whether or not the two sequences\n * are equal.\n *\n * <span class=\"informal\">Checks to see of all values emitted by both observables are equal, in order.</span>\n *\n * <img src=\"./img/sequenceEqual.png\" width=\"100%\">\n *\n * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either\n * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom\n * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the\n * observables completes, the operator will wait for the other observable to complete; If the other\n * observable emits before completing, the returned observable will emit `false` and complete. If one observable never\n * completes or emits after the other complets, the returned observable will never complete.\n *\n * @example <caption>figure out if the Konami code matches</caption>\n * var code = Rx.Observable.from([\n *  \"ArrowUp\",\n *  \"ArrowUp\",\n *  \"ArrowDown\",\n *  \"ArrowDown\",\n *  \"ArrowLeft\",\n *  \"ArrowRight\",\n *  \"ArrowLeft\",\n *  \"ArrowRight\",\n *  \"KeyB\",\n *  \"KeyA\",\n *  \"Enter\" // no start key, clearly.\n * ]);\n *\n * var keys = Rx.Observable.fromEvent(document, 'keyup')\n *  .map(e => e.code);\n * var matches = keys.bufferCount(11, 1)\n *  .mergeMap(\n *    last11 =>\n *      Rx.Observable.from(last11)\n *        .sequenceEqual(code)\n *   );\n * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n * @see {@link withLatestFrom}\n *\n * @param {Observable} compareTo The observable sequence to compare the source sequence to.\n * @param {function} [comparor] An optional function to compare each value pair\n * @return {Observable} An Observable of a single boolean value representing whether or not\n * the values emitted by both observables were equal in sequence.\n * @method sequenceEqual\n * @owner Observable\n */\n\nexport function sequenceEqual(compareTo, comparor) {\n  return function (source) {\n    return source.lift(new SequenceEqualOperator(compareTo, comparor));\n  };\n}\nexport var SequenceEqualOperator = /*#__PURE__*/function () {\n  function SequenceEqualOperator(compareTo, comparor) {\n    _classCallCheck(this, SequenceEqualOperator);\n\n    this.compareTo = compareTo;\n    this.comparor = comparor;\n  }\n\n  _createClass(SequenceEqualOperator, [{\n    key: \"call\",\n    value: function call(subscriber, source) {\n      return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparor));\n    }\n  }]);\n\n  return SequenceEqualOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nexport var SequenceEqualSubscriber = /*#__PURE__*/function (_Subscriber) {\n  _inherits(SequenceEqualSubscriber, _Subscriber);\n\n  var _super = _createSuper(SequenceEqualSubscriber);\n\n  function SequenceEqualSubscriber(destination, compareTo, comparor) {\n    var _this;\n\n    _classCallCheck(this, SequenceEqualSubscriber);\n\n    _this = _super.call(this, destination);\n    _this.compareTo = compareTo;\n    _this.comparor = comparor;\n    _this._a = [];\n    _this._b = [];\n    _this._oneComplete = false;\n\n    _this.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _assertThisInitialized(_this))));\n\n    return _this;\n  }\n\n  _createClass(SequenceEqualSubscriber, [{\n    key: \"_next\",\n    value: function _next(value) {\n      if (this._oneComplete && this._b.length === 0) {\n        this.emit(false);\n      } else {\n        this._a.push(value);\n\n        this.checkValues();\n      }\n    }\n  }, {\n    key: \"_complete\",\n    value: function _complete() {\n      if (this._oneComplete) {\n        this.emit(this._a.length === 0 && this._b.length === 0);\n      } else {\n        this._oneComplete = true;\n      }\n    }\n  }, {\n    key: \"checkValues\",\n    value: function checkValues() {\n      var _a = this._a,\n          _b = this._b,\n          comparor = this.comparor;\n\n      while (_a.length > 0 && _b.length > 0) {\n        var a = _a.shift();\n\n        var b = _b.shift();\n\n        var areEqual = false;\n\n        if (comparor) {\n          areEqual = tryCatch(comparor)(a, b);\n\n          if (areEqual === errorObject) {\n            this.destination.error(errorObject.e);\n          }\n        } else {\n          areEqual = a === b;\n        }\n\n        if (!areEqual) {\n          this.emit(false);\n        }\n      }\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(value) {\n      var destination = this.destination;\n      destination.next(value);\n      destination.complete();\n    }\n  }, {\n    key: \"nextB\",\n    value: function nextB(value) {\n      if (this._oneComplete && this._a.length === 0) {\n        this.emit(false);\n      } else {\n        this._b.push(value);\n\n        this.checkValues();\n      }\n    }\n  }]);\n\n  return SequenceEqualSubscriber;\n}(Subscriber);\n\nvar SequenceEqualCompareToSubscriber = /*#__PURE__*/function (_Subscriber2) {\n  _inherits(SequenceEqualCompareToSubscriber, _Subscriber2);\n\n  var _super2 = _createSuper(SequenceEqualCompareToSubscriber);\n\n  function SequenceEqualCompareToSubscriber(destination, parent) {\n    var _this2;\n\n    _classCallCheck(this, SequenceEqualCompareToSubscriber);\n\n    _this2 = _super2.call(this, destination);\n    _this2.parent = parent;\n    return _this2;\n  }\n\n  _createClass(SequenceEqualCompareToSubscriber, [{\n    key: \"_next\",\n    value: function _next(value) {\n      this.parent.nextB(value);\n    }\n  }, {\n    key: \"_error\",\n    value: function _error(err) {\n      this.parent.error(err);\n    }\n  }, {\n    key: \"_complete\",\n    value: function _complete() {\n      this.parent._complete();\n    }\n  }]);\n\n  return SequenceEqualCompareToSubscriber;\n}(Subscriber);","map":{"version":3,"sources":["../../../src/internal/operators/sequenceEqual.ts"],"names":[],"mappings":"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","sourcesContent":["import { Subscriber } from '../Subscriber';\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\n/**\n * Compares all values of two observables in sequence using an optional comparor function\n * and returns an observable of a single boolean value representing whether or not the two sequences\n * are equal.\n *\n * <span class=\"informal\">Checks to see of all values emitted by both observables are equal, in order.</span>\n *\n * <img src=\"./img/sequenceEqual.png\" width=\"100%\">\n *\n * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either\n * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom\n * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the\n * observables completes, the operator will wait for the other observable to complete; If the other\n * observable emits before completing, the returned observable will emit `false` and complete. If one observable never\n * completes or emits after the other complets, the returned observable will never complete.\n *\n * @example <caption>figure out if the Konami code matches</caption>\n * var code = Rx.Observable.from([\n *  \"ArrowUp\",\n *  \"ArrowUp\",\n *  \"ArrowDown\",\n *  \"ArrowDown\",\n *  \"ArrowLeft\",\n *  \"ArrowRight\",\n *  \"ArrowLeft\",\n *  \"ArrowRight\",\n *  \"KeyB\",\n *  \"KeyA\",\n *  \"Enter\" // no start key, clearly.\n * ]);\n *\n * var keys = Rx.Observable.fromEvent(document, 'keyup')\n *  .map(e => e.code);\n * var matches = keys.bufferCount(11, 1)\n *  .mergeMap(\n *    last11 =>\n *      Rx.Observable.from(last11)\n *        .sequenceEqual(code)\n *   );\n * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n * @see {@link withLatestFrom}\n *\n * @param {Observable} compareTo The observable sequence to compare the source sequence to.\n * @param {function} [comparor] An optional function to compare each value pair\n * @return {Observable} An Observable of a single boolean value representing whether or not\n * the values emitted by both observables were equal in sequence.\n * @method sequenceEqual\n * @owner Observable\n */\nexport function sequenceEqual(compareTo, comparor) {\n    return (source) => source.lift(new SequenceEqualOperator(compareTo, comparor));\n}\nexport class SequenceEqualOperator {\n    constructor(compareTo, comparor) {\n        this.compareTo = compareTo;\n        this.comparor = comparor;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparor));\n    }\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class SequenceEqualSubscriber extends Subscriber {\n    constructor(destination, compareTo, comparor) {\n        super(destination);\n        this.compareTo = compareTo;\n        this.comparor = comparor;\n        this._a = [];\n        this._b = [];\n        this._oneComplete = false;\n        this.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, this)));\n    }\n    _next(value) {\n        if (this._oneComplete && this._b.length === 0) {\n            this.emit(false);\n        }\n        else {\n            this._a.push(value);\n            this.checkValues();\n        }\n    }\n    _complete() {\n        if (this._oneComplete) {\n            this.emit(this._a.length === 0 && this._b.length === 0);\n        }\n        else {\n            this._oneComplete = true;\n        }\n    }\n    checkValues() {\n        const { _a, _b, comparor } = this;\n        while (_a.length > 0 && _b.length > 0) {\n            let a = _a.shift();\n            let b = _b.shift();\n            let areEqual = false;\n            if (comparor) {\n                areEqual = tryCatch(comparor)(a, b);\n                if (areEqual === errorObject) {\n                    this.destination.error(errorObject.e);\n                }\n            }\n            else {\n                areEqual = a === b;\n            }\n            if (!areEqual) {\n                this.emit(false);\n            }\n        }\n    }\n    emit(value) {\n        const { destination } = this;\n        destination.next(value);\n        destination.complete();\n    }\n    nextB(value) {\n        if (this._oneComplete && this._a.length === 0) {\n            this.emit(false);\n        }\n        else {\n            this._b.push(value);\n            this.checkValues();\n        }\n    }\n}\nclass SequenceEqualCompareToSubscriber extends Subscriber {\n    constructor(destination, parent) {\n        super(destination);\n        this.parent = parent;\n    }\n    _next(value) {\n        this.parent.nextB(value);\n    }\n    _error(err) {\n        this.parent.error(err);\n    }\n    _complete() {\n        this.parent._complete();\n    }\n}\n//# sourceMappingURL=sequenceEqual.js.map"]},"metadata":{},"sourceType":"module"}