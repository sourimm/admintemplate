{"ast":null,"code":"import _inherits from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n/* tslint:enable:max-line-length */\n\n/**\n * Recursively projects each source value to an Observable which is merged in\n * the output Observable.\n *\n * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n * projection function to every source value as well as every output value.\n * It's recursive.</span>\n *\n * <img src=\"./img/expand.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger. *Expand* will re-emit on the output\n * Observable every source value. Then, each output value is given to the\n * `project` function which returns an inner Observable to be merged on the\n * output Observable. Those output values resulting from the projection are also\n * given to the `project` function to produce new output values. This is how\n * *expand* behaves recursively.\n *\n * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var powersOfTwo = clicks\n *   .mapTo(1)\n *   .expand(x => Rx.Observable.of(2 * x).delay(1000))\n *   .take(10);\n * powersOfTwo.subscribe(x => console.log(x));\n *\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n *\n * @param {function(value: T, index: number) => Observable} project A function\n * that, when applied to an item emitted by the source or the output Observable,\n * returns an Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n * each projected inner Observable.\n * @return {Observable} An Observable that emits the source values and also\n * result of applying the projection function to each value emitted on the\n * output Observable and and merging the results of the Observables obtained\n * from this transformation.\n * @method expand\n * @owner Observable\n */\n\nexport function expand(project) {\n  var concurrent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.POSITIVE_INFINITY;\n  var scheduler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n  concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n  return function (source) {\n    return source.lift(new ExpandOperator(project, concurrent, scheduler));\n  };\n}\nexport var ExpandOperator = /*#__PURE__*/function () {\n  function ExpandOperator(project, concurrent, scheduler) {\n    _classCallCheck(this, ExpandOperator);\n\n    this.project = project;\n    this.concurrent = concurrent;\n    this.scheduler = scheduler;\n  }\n\n  _createClass(ExpandOperator, [{\n    key: \"call\",\n    value: function call(subscriber, source) {\n      return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));\n    }\n  }]);\n\n  return ExpandOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nexport var ExpandSubscriber = /*#__PURE__*/function (_OuterSubscriber) {\n  _inherits(ExpandSubscriber, _OuterSubscriber);\n\n  var _super = _createSuper(ExpandSubscriber);\n\n  function ExpandSubscriber(destination, project, concurrent, scheduler) {\n    var _this;\n\n    _classCallCheck(this, ExpandSubscriber);\n\n    _this = _super.call(this, destination);\n    _this.project = project;\n    _this.concurrent = concurrent;\n    _this.scheduler = scheduler;\n    _this.index = 0;\n    _this.active = 0;\n    _this.hasCompleted = false;\n\n    if (concurrent < Number.POSITIVE_INFINITY) {\n      _this.buffer = [];\n    }\n\n    return _this;\n  }\n\n  _createClass(ExpandSubscriber, [{\n    key: \"_next\",\n    value: function _next(value) {\n      var destination = this.destination;\n\n      if (destination.closed) {\n        this._complete();\n\n        return;\n      }\n\n      var index = this.index++;\n\n      if (this.active < this.concurrent) {\n        destination.next(value);\n        var result = tryCatch(this.project)(value, index);\n\n        if (result === errorObject) {\n          destination.error(errorObject.e);\n        } else if (!this.scheduler) {\n          this.subscribeToProjection(result, value, index);\n        } else {\n          var state = {\n            subscriber: this,\n            result: result,\n            value: value,\n            index: index\n          };\n          this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));\n        }\n      } else {\n        this.buffer.push(value);\n      }\n    }\n  }, {\n    key: \"subscribeToProjection\",\n    value: function subscribeToProjection(result, value, index) {\n      this.active++;\n      this.add(subscribeToResult(this, result, value, index));\n    }\n  }, {\n    key: \"_complete\",\n    value: function _complete() {\n      this.hasCompleted = true;\n\n      if (this.hasCompleted && this.active === 0) {\n        this.destination.complete();\n      }\n    }\n  }, {\n    key: \"notifyNext\",\n    value: function notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n      this._next(innerValue);\n    }\n  }, {\n    key: \"notifyComplete\",\n    value: function notifyComplete(innerSub) {\n      var buffer = this.buffer;\n      this.remove(innerSub);\n      this.active--;\n\n      if (buffer && buffer.length > 0) {\n        this._next(buffer.shift());\n      }\n\n      if (this.hasCompleted && this.active === 0) {\n        this.destination.complete();\n      }\n    }\n  }], [{\n    key: \"dispatch\",\n    value: function dispatch(arg) {\n      var subscriber = arg.subscriber,\n          result = arg.result,\n          value = arg.value,\n          index = arg.index;\n      subscriber.subscribeToProjection(result, value, index);\n    }\n  }]);\n\n  return ExpandSubscriber;\n}(OuterSubscriber);","map":{"version":3,"sources":["../../../src/internal/operators/expand.ts"],"names":[],"mappings":";;;;AAGA,SAAS,QAAT,QAAyB,kBAAzB;AACA,SAAS,WAAT,QAA4B,qBAA5B;AAEA,SAAS,eAAT,QAAgC,oBAAhC;AAEA,SAAS,iBAAT,QAAkC,2BAAlC;AAMA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6CA,OAAM,SAAA,MAAA,CAAuB,OAAvB,EAE2D;AAAA,MADpC,UACoC,uEADf,MAAM,CAAC,iBACQ;AAAA,MAApC,SAAoC,uEAAT,SAAS;AAC/D,EAAA,UAAU,GAAG,CAAC,UAAU,IAAI,CAAf,IAAoB,CAApB,GAAwB,MAAM,CAAC,iBAA/B,GAAmD,UAAhE;AAEA,SAAO,UAAC,MAAD;AAAA,WAA2B,MAAM,CAAC,IAAP,CAAY,IAAI,cAAJ,CAAmB,OAAnB,EAA4B,UAA5B,EAAwC,SAAxC,CAAZ,CAA3B;AAAA,GAAP;AACD;AAED,WAAM,cAAN;AACE,0BAAoB,OAApB,EACoB,UADpB,EAEoB,SAFpB,EAE4C;AAAA;;AAFxB,SAAA,OAAA,GAAA,OAAA;AACA,SAAA,UAAA,GAAA,UAAA;AACA,SAAA,SAAA,GAAA,SAAA;AACnB;;AAJH;AAAA;AAAA,yBAMO,UANP,EAMkC,MANlC,EAM6C;AACzC,aAAO,MAAM,CAAC,SAAP,CAAiB,IAAI,gBAAJ,CAAqB,UAArB,EAAiC,KAAK,OAAtC,EAA+C,KAAK,UAApD,EAAgE,KAAK,SAArE,CAAjB,CAAP;AACD;AARH;;AAAA;AAAA;AAkBA;;;;;;AAKA,WAAM,gBAAN;AAAA;;AAAA;;AAME,4BAAY,WAAZ,EACoB,OADpB,EAEoB,UAFpB,EAGoB,SAHpB,EAG4C;AAAA;;AAAA;;AAC1C,8BAAM,WAAN;AAHkB,UAAA,OAAA,GAAA,OAAA;AACA,UAAA,UAAA,GAAA,UAAA;AACA,UAAA,SAAA,GAAA,SAAA;AARZ,UAAA,KAAA,GAAgB,CAAhB;AACA,UAAA,MAAA,GAAiB,CAAjB;AACA,UAAA,YAAA,GAAwB,KAAxB;;AAQN,QAAI,UAAU,GAAG,MAAM,CAAC,iBAAxB,EAA2C;AACzC,YAAK,MAAL,GAAc,EAAd;AACD;;AAJyC;AAK3C;;AAdH;AAAA;AAAA,0BAqBkB,KArBlB,EAqB4B;AACxB,UAAM,WAAW,GAAG,KAAK,WAAzB;;AAEA,UAAI,WAAW,CAAC,MAAhB,EAAwB;AACtB,aAAK,SAAL;;AACA;AACD;;AAED,UAAM,KAAK,GAAG,KAAK,KAAL,EAAd;;AACA,UAAI,KAAK,MAAL,GAAc,KAAK,UAAvB,EAAmC;AACjC,QAAA,WAAW,CAAC,IAAZ,CAAiB,KAAjB;AACA,YAAI,MAAM,GAAG,QAAQ,CAAC,KAAK,OAAN,CAAR,CAAuB,KAAvB,EAA8B,KAA9B,CAAb;;AACA,YAAI,MAAM,KAAK,WAAf,EAA4B;AAC1B,UAAA,WAAW,CAAC,KAAZ,CAAkB,WAAW,CAAC,CAA9B;AACD,SAFD,MAEO,IAAI,CAAC,KAAK,SAAV,EAAqB;AAC1B,eAAK,qBAAL,CAA2B,MAA3B,EAAmC,KAAnC,EAA0C,KAA1C;AACD,SAFM,MAEA;AACL,cAAM,KAAK,GAAsB;AAAE,YAAA,UAAU,EAAE,IAAd;AAAoB,YAAA,MAAM,EAAN,MAApB;AAA4B,YAAA,KAAK,EAAL,KAA5B;AAAmC,YAAA,KAAK,EAAL;AAAnC,WAAjC;AACA,eAAK,GAAL,CAAS,KAAK,SAAL,CAAe,QAAf,CAA2C,gBAAgB,CAAC,QAA5D,EAAsE,CAAtE,EAAyE,KAAzE,CAAT;AACD;AACF,OAXD,MAWO;AACL,aAAK,MAAL,CAAY,IAAZ,CAAiB,KAAjB;AACD;AACF;AA5CH;AAAA;AAAA,0CA8CgC,MA9ChC,EA8C6C,KA9C7C,EA8CuD,KA9CvD,EA8CoE;AAChE,WAAK,MAAL;AACA,WAAK,GAAL,CAAS,iBAAiB,CAAO,IAAP,EAAa,MAAb,EAAqB,KAArB,EAA4B,KAA5B,CAA1B;AACD;AAjDH;AAAA;AAAA,gCAmDqB;AACjB,WAAK,YAAL,GAAoB,IAApB;;AACA,UAAI,KAAK,YAAL,IAAqB,KAAK,MAAL,KAAgB,CAAzC,EAA4C;AAC1C,aAAK,WAAL,CAAiB,QAAjB;AACD;AACF;AAxDH;AAAA;AAAA,+BA0Da,UA1Db,EA0D4B,UA1D5B,EA2Da,UA3Db,EA2DiC,UA3DjC,EA4Da,QA5Db,EA4D4C;AACxC,WAAK,KAAL,CAAW,UAAX;AACD;AA9DH;AAAA;AAAA,mCAgEiB,QAhEjB,EAgEuC;AACnC,UAAM,MAAM,GAAG,KAAK,MAApB;AACA,WAAK,MAAL,CAAY,QAAZ;AACA,WAAK,MAAL;;AACA,UAAI,MAAM,IAAI,MAAM,CAAC,MAAP,GAAgB,CAA9B,EAAiC;AAC/B,aAAK,KAAL,CAAW,MAAM,CAAC,KAAP,EAAX;AACD;;AACD,UAAI,KAAK,YAAL,IAAqB,KAAK,MAAL,KAAgB,CAAzC,EAA4C;AAC1C,aAAK,WAAL,CAAiB,QAAjB;AACD;AACF;AA1EH;AAAA;AAAA,6BAgBgC,GAhBhC,EAgBsD;AAAA,UAC3C,UAD2C,GACP,GADO,CAC3C,UAD2C;AAAA,UAC/B,MAD+B,GACP,GADO,CAC/B,MAD+B;AAAA,UACvB,KADuB,GACP,GADO,CACvB,KADuB;AAAA,UAChB,KADgB,GACP,GADO,CAChB,KADgB;AAElD,MAAA,UAAU,CAAC,qBAAX,CAAiC,MAAjC,EAAyC,KAAzC,EAAgD,KAAhD;AACD;AAnBH;;AAAA;AAAA,EAA4C,eAA5C","sourcesContent":["import { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n/* tslint:enable:max-line-length */\n/**\n * Recursively projects each source value to an Observable which is merged in\n * the output Observable.\n *\n * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n * projection function to every source value as well as every output value.\n * It's recursive.</span>\n *\n * <img src=\"./img/expand.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger. *Expand* will re-emit on the output\n * Observable every source value. Then, each output value is given to the\n * `project` function which returns an inner Observable to be merged on the\n * output Observable. Those output values resulting from the projection are also\n * given to the `project` function to produce new output values. This is how\n * *expand* behaves recursively.\n *\n * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var powersOfTwo = clicks\n *   .mapTo(1)\n *   .expand(x => Rx.Observable.of(2 * x).delay(1000))\n *   .take(10);\n * powersOfTwo.subscribe(x => console.log(x));\n *\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n *\n * @param {function(value: T, index: number) => Observable} project A function\n * that, when applied to an item emitted by the source or the output Observable,\n * returns an Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n * each projected inner Observable.\n * @return {Observable} An Observable that emits the source values and also\n * result of applying the projection function to each value emitted on the\n * output Observable and and merging the results of the Observables obtained\n * from this transformation.\n * @method expand\n * @owner Observable\n */\nexport function expand(project, concurrent = Number.POSITIVE_INFINITY, scheduler = undefined) {\n    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n    return (source) => source.lift(new ExpandOperator(project, concurrent, scheduler));\n}\nexport class ExpandOperator {\n    constructor(project, concurrent, scheduler) {\n        this.project = project;\n        this.concurrent = concurrent;\n        this.scheduler = scheduler;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));\n    }\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class ExpandSubscriber extends OuterSubscriber {\n    constructor(destination, project, concurrent, scheduler) {\n        super(destination);\n        this.project = project;\n        this.concurrent = concurrent;\n        this.scheduler = scheduler;\n        this.index = 0;\n        this.active = 0;\n        this.hasCompleted = false;\n        if (concurrent < Number.POSITIVE_INFINITY) {\n            this.buffer = [];\n        }\n    }\n    static dispatch(arg) {\n        const { subscriber, result, value, index } = arg;\n        subscriber.subscribeToProjection(result, value, index);\n    }\n    _next(value) {\n        const destination = this.destination;\n        if (destination.closed) {\n            this._complete();\n            return;\n        }\n        const index = this.index++;\n        if (this.active < this.concurrent) {\n            destination.next(value);\n            let result = tryCatch(this.project)(value, index);\n            if (result === errorObject) {\n                destination.error(errorObject.e);\n            }\n            else if (!this.scheduler) {\n                this.subscribeToProjection(result, value, index);\n            }\n            else {\n                const state = { subscriber: this, result, value, index };\n                this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));\n            }\n        }\n        else {\n            this.buffer.push(value);\n        }\n    }\n    subscribeToProjection(result, value, index) {\n        this.active++;\n        this.add(subscribeToResult(this, result, value, index));\n    }\n    _complete() {\n        this.hasCompleted = true;\n        if (this.hasCompleted && this.active === 0) {\n            this.destination.complete();\n        }\n    }\n    notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this._next(innerValue);\n    }\n    notifyComplete(innerSub) {\n        const buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer && buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        if (this.hasCompleted && this.active === 0) {\n            this.destination.complete();\n        }\n    }\n}\n//# sourceMappingURL=expand.js.map"]},"metadata":{},"sourceType":"module"}