{"ast":null,"code":"import _classCallCheck from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { isArray } from './util/isArray';\nimport { isObject } from './util/isObject';\nimport { isFunction } from './util/isFunction';\nimport { tryCatch } from './util/tryCatch';\nimport { errorObject } from './util/errorObject';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\n/**\r\n * Represents a disposable resource, such as the execution of an Observable. A\r\n * Subscription has one important method, `unsubscribe`, that takes no argument\r\n * and just disposes the resource held by the subscription.\r\n *\r\n * Additionally, subscriptions may be grouped together through the `add()`\r\n * method, which will attach a child Subscription to the current Subscription.\r\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\r\n * will be unsubscribed as well.\r\n *\r\n * @class Subscription\r\n */\n\nexport var Subscription = /*@__PURE__*/function () {\n  var Subscription = /*#__PURE__*/function () {\n    /**\r\n     * @param {function(): void} [unsubscribe] A function describing how to\r\n     * perform the disposal of resources when the `unsubscribe` method is called.\r\n     */\n    function Subscription(unsubscribe) {\n      _classCallCheck(this, Subscription);\n\n      /**\r\n       * A flag to indicate whether this Subscription has already been unsubscribed.\r\n       * @type {boolean}\r\n       */\n      this.closed = false;\n      /** @internal */\n\n      this._parent = null;\n      /** @internal */\n\n      this._parents = null;\n      /** @internal */\n\n      this._subscriptions = null;\n\n      if (unsubscribe) {\n        this._unsubscribe = unsubscribe;\n      }\n    }\n    /**\r\n     * Disposes the resources held by the subscription. May, for instance, cancel\r\n     * an ongoing Observable execution or cancel any other type of work that\r\n     * started when the Subscription was created.\r\n     * @return {void}\r\n     */\n\n\n    _createClass(Subscription, [{\n      key: \"unsubscribe\",\n      value: function unsubscribe() {\n        var hasErrors = false;\n        var errors;\n\n        if (this.closed) {\n          return;\n        }\n\n        var _parent = this._parent,\n            _parents = this._parents,\n            _unsubscribe = this._unsubscribe,\n            _subscriptions = this._subscriptions;\n        this.closed = true;\n        this._parent = null;\n        this._parents = null; // null out _subscriptions first so any child subscriptions that attempt\n        // to remove themselves from this subscription will noop\n\n        this._subscriptions = null;\n        var index = -1;\n        var len = _parents ? _parents.length : 0; // if this._parent is null, then so is this._parents, and we\n        // don't have to remove ourselves from any parent subscriptions.\n\n        while (_parent) {\n          _parent.remove(this); // if this._parents is null or index >= len,\n          // then _parent is set to null, and the loop exits\n\n\n          _parent = ++index < len && _parents[index] || null;\n        }\n\n        if (isFunction(_unsubscribe)) {\n          var trial = tryCatch(_unsubscribe).call(this);\n\n          if (trial === errorObject) {\n            hasErrors = true;\n            errors = errors || (errorObject.e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(errorObject.e.errors) : [errorObject.e]);\n          }\n        }\n\n        if (isArray(_subscriptions)) {\n          index = -1;\n          len = _subscriptions.length;\n\n          while (++index < len) {\n            var sub = _subscriptions[index];\n\n            if (isObject(sub)) {\n              var _trial = tryCatch(sub.unsubscribe).call(sub);\n\n              if (_trial === errorObject) {\n                hasErrors = true;\n                errors = errors || [];\n                var err = errorObject.e;\n\n                if (err instanceof UnsubscriptionError) {\n                  errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n                } else {\n                  errors.push(err);\n                }\n              }\n            }\n          }\n        }\n\n        if (hasErrors) {\n          throw new UnsubscriptionError(errors);\n        }\n      }\n      /**\r\n       * Adds a tear down to be called during the unsubscribe() of this\r\n       * Subscription.\r\n       *\r\n       * If the tear down being added is a subscription that is already\r\n       * unsubscribed, is the same reference `add` is being called on, or is\r\n       * `Subscription.EMPTY`, it will not be added.\r\n       *\r\n       * If this subscription is already in an `closed` state, the passed\r\n       * tear down logic will be executed immediately.\r\n       *\r\n       * @param {TeardownLogic} teardown The additional logic to execute on\r\n       * teardown.\r\n       * @return {Subscription} Returns the Subscription used or created to be\r\n       * added to the inner subscriptions list. This Subscription can be used with\r\n       * `remove()` to remove the passed teardown logic from the inner subscriptions\r\n       * list.\r\n       */\n\n    }, {\n      key: \"add\",\n      value: function add(teardown) {\n        if (!teardown || teardown === Subscription.EMPTY) {\n          return Subscription.EMPTY;\n        }\n\n        if (teardown === this) {\n          return this;\n        }\n\n        var subscription = teardown;\n\n        switch (typeof teardown) {\n          case 'function':\n            subscription = new Subscription(teardown);\n\n          case 'object':\n            if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n              return subscription;\n            } else if (this.closed) {\n              subscription.unsubscribe();\n              return subscription;\n            } else if (typeof subscription._addParent !== 'function'\n            /* quack quack */\n            ) {\n                var tmp = subscription;\n                subscription = new Subscription();\n                subscription._subscriptions = [tmp];\n              }\n\n            break;\n\n          default:\n            throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n        }\n\n        var subscriptions = this._subscriptions || (this._subscriptions = []);\n        subscriptions.push(subscription);\n\n        subscription._addParent(this);\n\n        return subscription;\n      }\n      /**\r\n       * Removes a Subscription from the internal list of subscriptions that will\r\n       * unsubscribe during the unsubscribe process of this Subscription.\r\n       * @param {Subscription} subscription The subscription to remove.\r\n       * @return {void}\r\n       */\n\n    }, {\n      key: \"remove\",\n      value: function remove(subscription) {\n        var subscriptions = this._subscriptions;\n\n        if (subscriptions) {\n          var subscriptionIndex = subscriptions.indexOf(subscription);\n\n          if (subscriptionIndex !== -1) {\n            subscriptions.splice(subscriptionIndex, 1);\n          }\n        }\n      }\n      /** @internal */\n\n    }, {\n      key: \"_addParent\",\n      value: function _addParent(parent) {\n        var _parent = this._parent,\n            _parents = this._parents;\n\n        if (!_parent || _parent === parent) {\n          // If we don't have a parent, or the new parent is the same as the\n          // current parent, then set this._parent to the new parent.\n          this._parent = parent;\n        } else if (!_parents) {\n          // If there's already one parent, but not multiple, allocate an Array to\n          // store the rest of the parent Subscriptions.\n          this._parents = [parent];\n        } else if (_parents.indexOf(parent) === -1) {\n          // Only add the new parent to the _parents list if it's not already there.\n          _parents.push(parent);\n        }\n      }\n    }]);\n\n    return Subscription;\n  }();\n  /** @nocollapse */\n\n\n  Subscription.EMPTY = function (empty) {\n    empty.closed = true;\n    return empty;\n  }(new Subscription());\n\n  return Subscription;\n}();\n\nfunction flattenUnsubscriptionErrors(errors) {\n  return errors.reduce(function (errs, err) {\n    return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);\n  }, []);\n}","map":null,"metadata":{},"sourceType":"module"}