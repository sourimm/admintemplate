{"ast":null,"code":"import _classCallCheck from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Action } from './Action';\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nexport var AsyncAction = /*#__PURE__*/function (_Action) {\n  _inherits(AsyncAction, _Action);\n\n  var _super = _createSuper(AsyncAction);\n\n  function AsyncAction(scheduler, work) {\n    var _this;\n\n    _classCallCheck(this, AsyncAction);\n\n    _this = _super.call(this, scheduler, work);\n    _this.scheduler = scheduler;\n    _this.work = work;\n    _this.pending = false;\n    return _this;\n  }\n\n  _createClass(AsyncAction, [{\n    key: \"schedule\",\n    value: function schedule(state) {\n      var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      if (this.closed) {\n        return this;\n      } // Always replace the current state with the new state.\n\n\n      this.state = state;\n      var id = this.id;\n      var scheduler = this.scheduler; //\n      // Important implementation note:\n      //\n      // Actions only execute once by default, unless rescheduled from within the\n      // scheduled callback. This allows us to implement single and repeat\n      // actions via the same code path, without adding API surface area, as well\n      // as mimic traditional recursion but across asynchronous boundaries.\n      //\n      // However, JS runtimes and timers distinguish between intervals achieved by\n      // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n      // serial `setTimeout` calls can be individually delayed, which delays\n      // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n      // guarantee the interval callback will be invoked more precisely to the\n      // interval period, regardless of load.\n      //\n      // Therefore, we use `setInterval` to schedule single and repeat actions.\n      // If the action reschedules itself with the same delay, the interval is not\n      // canceled. If the action doesn't reschedule, or reschedules with a\n      // different delay, the interval will be canceled after scheduled callback\n      // execution.\n      //\n\n      if (id != null) {\n        this.id = this.recycleAsyncId(scheduler, id, delay);\n      } // Set the pending flag indicating that this action has been scheduled, or\n      // has recursively rescheduled itself.\n\n\n      this.pending = true;\n      this.delay = delay; // If this action has already an async Id, don't request a new one.\n\n      this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n      return this;\n    }\n  }, {\n    key: \"requestAsyncId\",\n    value: function requestAsyncId(scheduler, id) {\n      var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      return setInterval(scheduler.flush.bind(scheduler, this), delay);\n    }\n  }, {\n    key: \"recycleAsyncId\",\n    value: function recycleAsyncId(scheduler, id) {\n      var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      // If this action is rescheduled with the same delay time, don't clear the interval id.\n      if (delay !== null && this.delay === delay && this.pending === false) {\n        return id;\n      } // Otherwise, if the action's delay time is different from the current delay,\n      // or the action has been rescheduled before it's executed, clear the interval id\n\n\n      return clearInterval(id) && undefined || undefined;\n    }\n    /**\n     * Immediately executes this action and the `work` it contains.\n     * @return {any}\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute(state, delay) {\n      if (this.closed) {\n        return new Error('executing a cancelled action');\n      }\n\n      this.pending = false;\n\n      var error = this._execute(state, delay);\n\n      if (error) {\n        return error;\n      } else if (this.pending === false && this.id != null) {\n        // Dequeue if the action didn't reschedule itself. Don't call\n        // unsubscribe(), because the action could reschedule later.\n        // For example:\n        // ```\n        // scheduler.schedule(function doWork(counter) {\n        //   /* ... I'm a busy worker bee ... */\n        //   var originalAction = this;\n        //   /* wait 100ms before rescheduling the action */\n        //   setTimeout(function () {\n        //     originalAction.schedule(counter + 1);\n        //   }, 100);\n        // }, 1000);\n        // ```\n        this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n      }\n    }\n  }, {\n    key: \"_execute\",\n    value: function _execute(state, delay) {\n      var errored = false;\n      var errorValue = undefined;\n\n      try {\n        this.work(state);\n      } catch (e) {\n        errored = true;\n        errorValue = !!e && e || new Error(e);\n      }\n\n      if (errored) {\n        this.unsubscribe();\n        return errorValue;\n      }\n    }\n    /** @deprecated This is an internal implementation detail, do not use. */\n\n  }, {\n    key: \"_unsubscribe\",\n    value: function _unsubscribe() {\n      var id = this.id;\n      var scheduler = this.scheduler;\n      var actions = scheduler.actions;\n      var index = actions.indexOf(this);\n      this.work = null;\n      this.state = null;\n      this.pending = false;\n      this.scheduler = null;\n\n      if (index !== -1) {\n        actions.splice(index, 1);\n      }\n\n      if (id != null) {\n        this.id = this.recycleAsyncId(scheduler, id, null);\n      }\n\n      this.delay = null;\n    }\n  }]);\n\n  return AsyncAction;\n}(Action);","map":{"version":3,"sources":["../../../src/internal/scheduler/AsyncAction.ts"],"names":[],"mappings":"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","sourcesContent":["import { Action } from './Action';\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class AsyncAction extends Action {\n    constructor(scheduler, work) {\n        super(scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n        this.pending = false;\n    }\n    schedule(state, delay = 0) {\n        if (this.closed) {\n            return this;\n        }\n        // Always replace the current state with the new state.\n        this.state = state;\n        const id = this.id;\n        const scheduler = this.scheduler;\n        //\n        // Important implementation note:\n        //\n        // Actions only execute once by default, unless rescheduled from within the\n        // scheduled callback. This allows us to implement single and repeat\n        // actions via the same code path, without adding API surface area, as well\n        // as mimic traditional recursion but across asynchronous boundaries.\n        //\n        // However, JS runtimes and timers distinguish between intervals achieved by\n        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n        // serial `setTimeout` calls can be individually delayed, which delays\n        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n        // guarantee the interval callback will be invoked more precisely to the\n        // interval period, regardless of load.\n        //\n        // Therefore, we use `setInterval` to schedule single and repeat actions.\n        // If the action reschedules itself with the same delay, the interval is not\n        // canceled. If the action doesn't reschedule, or reschedules with a\n        // different delay, the interval will be canceled after scheduled callback\n        // execution.\n        //\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, delay);\n        }\n        // Set the pending flag indicating that this action has been scheduled, or\n        // has recursively rescheduled itself.\n        this.pending = true;\n        this.delay = delay;\n        // If this action has already an async Id, don't request a new one.\n        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n        return this;\n    }\n    requestAsyncId(scheduler, id, delay = 0) {\n        return setInterval(scheduler.flush.bind(scheduler, this), delay);\n    }\n    recycleAsyncId(scheduler, id, delay = 0) {\n        // If this action is rescheduled with the same delay time, don't clear the interval id.\n        if (delay !== null && this.delay === delay && this.pending === false) {\n            return id;\n        }\n        // Otherwise, if the action's delay time is different from the current delay,\n        // or the action has been rescheduled before it's executed, clear the interval id\n        return clearInterval(id) && undefined || undefined;\n    }\n    /**\n     * Immediately executes this action and the `work` it contains.\n     * @return {any}\n     */\n    execute(state, delay) {\n        if (this.closed) {\n            return new Error('executing a cancelled action');\n        }\n        this.pending = false;\n        const error = this._execute(state, delay);\n        if (error) {\n            return error;\n        }\n        else if (this.pending === false && this.id != null) {\n            // Dequeue if the action didn't reschedule itself. Don't call\n            // unsubscribe(), because the action could reschedule later.\n            // For example:\n            // ```\n            // scheduler.schedule(function doWork(counter) {\n            //   /* ... I'm a busy worker bee ... */\n            //   var originalAction = this;\n            //   /* wait 100ms before rescheduling the action */\n            //   setTimeout(function () {\n            //     originalAction.schedule(counter + 1);\n            //   }, 100);\n            // }, 1000);\n            // ```\n            this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n        }\n    }\n    _execute(state, delay) {\n        let errored = false;\n        let errorValue = undefined;\n        try {\n            this.work(state);\n        }\n        catch (e) {\n            errored = true;\n            errorValue = !!e && e || new Error(e);\n        }\n        if (errored) {\n            this.unsubscribe();\n            return errorValue;\n        }\n    }\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _unsubscribe() {\n        const id = this.id;\n        const scheduler = this.scheduler;\n        const actions = scheduler.actions;\n        const index = actions.indexOf(this);\n        this.work = null;\n        this.state = null;\n        this.pending = false;\n        this.scheduler = null;\n        if (index !== -1) {\n            actions.splice(index, 1);\n        }\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, null);\n        }\n        this.delay = null;\n    }\n}\n//# sourceMappingURL=AsyncAction.js.map"]},"metadata":{},"sourceType":"module"}