{"ast":null,"code":"import _get from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\n/* tslint:enable:max-line-length */\n\n/**\n * Groups the items emitted by an Observable according to a specified criterion,\n * and emits these grouped items as `GroupedObservables`, one\n * {@link GroupedObservable} per group.\n *\n * <img src=\"./img/groupBy.png\" width=\"100%\">\n *\n * @example <caption>Group objects by id and return as array</caption>\n * Observable.of<Obj>({id: 1, name: 'aze1'},\n *                    {id: 2, name: 'sf2'},\n *                    {id: 2, name: 'dg2'},\n *                    {id: 1, name: 'erg1'},\n *                    {id: 1, name: 'df1'},\n *                    {id: 2, name: 'sfqfb2'},\n *                    {id: 3, name: 'qfs3'},\n *                    {id: 2, name: 'qsgqsfg2'}\n *     )\n *     .groupBy(p => p.id)\n *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))\n *     .subscribe(p => console.log(p));\n *\n * // displays:\n * // [ { id: 1, name: 'aze1' },\n * //   { id: 1, name: 'erg1' },\n * //   { id: 1, name: 'df1' } ]\n * //\n * // [ { id: 2, name: 'sf2' },\n * //   { id: 2, name: 'dg2' },\n * //   { id: 2, name: 'sfqfb2' },\n * //   { id: 2, name: 'qsgqsfg2' } ]\n * //\n * // [ { id: 3, name: 'qfs3' } ]\n *\n * @example <caption>Pivot data on the id field</caption>\n * Observable.of<Obj>({id: 1, name: 'aze1'},\n *                    {id: 2, name: 'sf2'},\n *                    {id: 2, name: 'dg2'},\n *                    {id: 1, name: 'erg1'},\n *                    {id: 1, name: 'df1'},\n *                    {id: 2, name: 'sfqfb2'},\n *                    {id: 3, name: 'qfs1'},\n *                    {id: 2, name: 'qsgqsfg2'}\n *                   )\n *     .groupBy(p => p.id, p => p.name)\n *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], [\"\" + group$.key]))\n *     .map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))\n *     .subscribe(p => console.log(p));\n *\n * // displays:\n * // { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }\n * // { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }\n * // { id: 3, values: [ 'qfs1' ] }\n *\n * @param {function(value: T): K} keySelector A function that extracts the key\n * for each item.\n * @param {function(value: T): R} [elementSelector] A function that extracts the\n * return element for each item.\n * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]\n * A function that returns an Observable to determine how long each group should\n * exist.\n * @return {Observable<GroupedObservable<K,R>>} An Observable that emits\n * GroupedObservables, each of which corresponds to a unique key value and each\n * of which emits those items from the source Observable that share that key\n * value.\n * @method groupBy\n * @owner Observable\n */\n\nexport function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {\n  return function (source) {\n    return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));\n  };\n}\n\nvar GroupByOperator = /*#__PURE__*/function () {\n  function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {\n    _classCallCheck(this, GroupByOperator);\n\n    this.keySelector = keySelector;\n    this.elementSelector = elementSelector;\n    this.durationSelector = durationSelector;\n    this.subjectSelector = subjectSelector;\n  }\n\n  _createClass(GroupByOperator, [{\n    key: \"call\",\n    value: function call(subscriber, source) {\n      return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));\n    }\n  }]);\n\n  return GroupByOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar GroupBySubscriber = /*#__PURE__*/function (_Subscriber) {\n  _inherits(GroupBySubscriber, _Subscriber);\n\n  var _super = _createSuper(GroupBySubscriber);\n\n  function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {\n    var _this;\n\n    _classCallCheck(this, GroupBySubscriber);\n\n    _this = _super.call(this, destination);\n    _this.keySelector = keySelector;\n    _this.elementSelector = elementSelector;\n    _this.durationSelector = durationSelector;\n    _this.subjectSelector = subjectSelector;\n    _this.groups = null;\n    _this.attemptedToUnsubscribe = false;\n    _this.count = 0;\n    return _this;\n  }\n\n  _createClass(GroupBySubscriber, [{\n    key: \"_next\",\n    value: function _next(value) {\n      var key;\n\n      try {\n        key = this.keySelector(value);\n      } catch (err) {\n        this.error(err);\n        return;\n      }\n\n      this._group(value, key);\n    }\n  }, {\n    key: \"_group\",\n    value: function _group(value, key) {\n      var groups = this.groups;\n\n      if (!groups) {\n        groups = this.groups = new Map();\n      }\n\n      var group = groups.get(key);\n      var element;\n\n      if (this.elementSelector) {\n        try {\n          element = this.elementSelector(value);\n        } catch (err) {\n          this.error(err);\n        }\n      } else {\n        element = value;\n      }\n\n      if (!group) {\n        group = this.subjectSelector ? this.subjectSelector() : new Subject();\n        groups.set(key, group);\n        var groupedObservable = new GroupedObservable(key, group, this);\n        this.destination.next(groupedObservable);\n\n        if (this.durationSelector) {\n          var duration;\n\n          try {\n            duration = this.durationSelector(new GroupedObservable(key, group));\n          } catch (err) {\n            this.error(err);\n            return;\n          }\n\n          this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));\n        }\n      }\n\n      if (!group.closed) {\n        group.next(element);\n      }\n    }\n  }, {\n    key: \"_error\",\n    value: function _error(err) {\n      var groups = this.groups;\n\n      if (groups) {\n        groups.forEach(function (group, key) {\n          group.error(err);\n        });\n        groups.clear();\n      }\n\n      this.destination.error(err);\n    }\n  }, {\n    key: \"_complete\",\n    value: function _complete() {\n      var groups = this.groups;\n\n      if (groups) {\n        groups.forEach(function (group, key) {\n          group.complete();\n        });\n        groups.clear();\n      }\n\n      this.destination.complete();\n    }\n  }, {\n    key: \"removeGroup\",\n    value: function removeGroup(key) {\n      this.groups.delete(key);\n    }\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe() {\n      if (!this.closed) {\n        this.attemptedToUnsubscribe = true;\n\n        if (this.count === 0) {\n          _get(_getPrototypeOf(GroupBySubscriber.prototype), \"unsubscribe\", this).call(this);\n        }\n      }\n    }\n  }]);\n\n  return GroupBySubscriber;\n}(Subscriber);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar GroupDurationSubscriber = /*#__PURE__*/function (_Subscriber2) {\n  _inherits(GroupDurationSubscriber, _Subscriber2);\n\n  var _super2 = _createSuper(GroupDurationSubscriber);\n\n  function GroupDurationSubscriber(key, group, parent) {\n    var _this2;\n\n    _classCallCheck(this, GroupDurationSubscriber);\n\n    _this2 = _super2.call(this, group);\n    _this2.key = key;\n    _this2.group = group;\n    _this2.parent = parent;\n    return _this2;\n  }\n\n  _createClass(GroupDurationSubscriber, [{\n    key: \"_next\",\n    value: function _next(value) {\n      this.complete();\n    }\n    /** @deprecated This is an internal implementation detail, do not use. */\n\n  }, {\n    key: \"_unsubscribe\",\n    value: function _unsubscribe() {\n      var parent = this.parent,\n          key = this.key;\n      this.key = this.parent = null;\n\n      if (parent) {\n        parent.removeGroup(key);\n      }\n    }\n  }]);\n\n  return GroupDurationSubscriber;\n}(Subscriber);\n/**\n * An Observable representing values belonging to the same group represented by\n * a common key. The values emitted by a GroupedObservable come from the source\n * Observable. The common key is available as the field `key` on a\n * GroupedObservable instance.\n *\n * @class GroupedObservable<K, T>\n */\n\n\nexport var GroupedObservable = /*#__PURE__*/function (_Observable) {\n  _inherits(GroupedObservable, _Observable);\n\n  var _super3 = _createSuper(GroupedObservable);\n\n  /** @deprecated Do not construct this type. Internal use only */\n  function GroupedObservable(key, groupSubject, refCountSubscription) {\n    var _this3;\n\n    _classCallCheck(this, GroupedObservable);\n\n    _this3 = _super3.call(this);\n    _this3.key = key;\n    _this3.groupSubject = groupSubject;\n    _this3.refCountSubscription = refCountSubscription;\n    return _this3;\n  }\n  /** @deprecated This is an internal implementation detail, do not use. */\n\n\n  _createClass(GroupedObservable, [{\n    key: \"_subscribe\",\n    value: function _subscribe(subscriber) {\n      var subscription = new Subscription();\n      var refCountSubscription = this.refCountSubscription,\n          groupSubject = this.groupSubject;\n\n      if (refCountSubscription && !refCountSubscription.closed) {\n        subscription.add(new InnerRefCountSubscription(refCountSubscription));\n      }\n\n      subscription.add(groupSubject.subscribe(subscriber));\n      return subscription;\n    }\n  }]);\n\n  return GroupedObservable;\n}(Observable);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nvar InnerRefCountSubscription = /*#__PURE__*/function (_Subscription) {\n  _inherits(InnerRefCountSubscription, _Subscription);\n\n  var _super4 = _createSuper(InnerRefCountSubscription);\n\n  function InnerRefCountSubscription(parent) {\n    var _this4;\n\n    _classCallCheck(this, InnerRefCountSubscription);\n\n    _this4 = _super4.call(this);\n    _this4.parent = parent;\n    parent.count++;\n    return _this4;\n  }\n\n  _createClass(InnerRefCountSubscription, [{\n    key: \"unsubscribe\",\n    value: function unsubscribe() {\n      var parent = this.parent;\n\n      if (!parent.closed && !this.closed) {\n        _get(_getPrototypeOf(InnerRefCountSubscription.prototype), \"unsubscribe\", this).call(this);\n\n        parent.count -= 1;\n\n        if (parent.count === 0 && parent.attemptedToUnsubscribe) {\n          parent.unsubscribe();\n        }\n      }\n    }\n  }]);\n\n  return InnerRefCountSubscription;\n}(Subscription);","map":{"version":3,"sources":["../../../src/internal/operators/groupBy.ts"],"names":[],"mappings":"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","sourcesContent":["import { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\n/* tslint:enable:max-line-length */\n/**\n * Groups the items emitted by an Observable according to a specified criterion,\n * and emits these grouped items as `GroupedObservables`, one\n * {@link GroupedObservable} per group.\n *\n * <img src=\"./img/groupBy.png\" width=\"100%\">\n *\n * @example <caption>Group objects by id and return as array</caption>\n * Observable.of<Obj>({id: 1, name: 'aze1'},\n *                    {id: 2, name: 'sf2'},\n *                    {id: 2, name: 'dg2'},\n *                    {id: 1, name: 'erg1'},\n *                    {id: 1, name: 'df1'},\n *                    {id: 2, name: 'sfqfb2'},\n *                    {id: 3, name: 'qfs3'},\n *                    {id: 2, name: 'qsgqsfg2'}\n *     )\n *     .groupBy(p => p.id)\n *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))\n *     .subscribe(p => console.log(p));\n *\n * // displays:\n * // [ { id: 1, name: 'aze1' },\n * //   { id: 1, name: 'erg1' },\n * //   { id: 1, name: 'df1' } ]\n * //\n * // [ { id: 2, name: 'sf2' },\n * //   { id: 2, name: 'dg2' },\n * //   { id: 2, name: 'sfqfb2' },\n * //   { id: 2, name: 'qsgqsfg2' } ]\n * //\n * // [ { id: 3, name: 'qfs3' } ]\n *\n * @example <caption>Pivot data on the id field</caption>\n * Observable.of<Obj>({id: 1, name: 'aze1'},\n *                    {id: 2, name: 'sf2'},\n *                    {id: 2, name: 'dg2'},\n *                    {id: 1, name: 'erg1'},\n *                    {id: 1, name: 'df1'},\n *                    {id: 2, name: 'sfqfb2'},\n *                    {id: 3, name: 'qfs1'},\n *                    {id: 2, name: 'qsgqsfg2'}\n *                   )\n *     .groupBy(p => p.id, p => p.name)\n *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], [\"\" + group$.key]))\n *     .map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))\n *     .subscribe(p => console.log(p));\n *\n * // displays:\n * // { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }\n * // { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }\n * // { id: 3, values: [ 'qfs1' ] }\n *\n * @param {function(value: T): K} keySelector A function that extracts the key\n * for each item.\n * @param {function(value: T): R} [elementSelector] A function that extracts the\n * return element for each item.\n * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]\n * A function that returns an Observable to determine how long each group should\n * exist.\n * @return {Observable<GroupedObservable<K,R>>} An Observable that emits\n * GroupedObservables, each of which corresponds to a unique key value and each\n * of which emits those items from the source Observable that share that key\n * value.\n * @method groupBy\n * @owner Observable\n */\nexport function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {\n    return (source) => source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));\n}\nclass GroupByOperator {\n    constructor(keySelector, elementSelector, durationSelector, subjectSelector) {\n        this.keySelector = keySelector;\n        this.elementSelector = elementSelector;\n        this.durationSelector = durationSelector;\n        this.subjectSelector = subjectSelector;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));\n    }\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass GroupBySubscriber extends Subscriber {\n    constructor(destination, keySelector, elementSelector, durationSelector, subjectSelector) {\n        super(destination);\n        this.keySelector = keySelector;\n        this.elementSelector = elementSelector;\n        this.durationSelector = durationSelector;\n        this.subjectSelector = subjectSelector;\n        this.groups = null;\n        this.attemptedToUnsubscribe = false;\n        this.count = 0;\n    }\n    _next(value) {\n        let key;\n        try {\n            key = this.keySelector(value);\n        }\n        catch (err) {\n            this.error(err);\n            return;\n        }\n        this._group(value, key);\n    }\n    _group(value, key) {\n        let groups = this.groups;\n        if (!groups) {\n            groups = this.groups = new Map();\n        }\n        let group = groups.get(key);\n        let element;\n        if (this.elementSelector) {\n            try {\n                element = this.elementSelector(value);\n            }\n            catch (err) {\n                this.error(err);\n            }\n        }\n        else {\n            element = value;\n        }\n        if (!group) {\n            group = (this.subjectSelector ? this.subjectSelector() : new Subject());\n            groups.set(key, group);\n            const groupedObservable = new GroupedObservable(key, group, this);\n            this.destination.next(groupedObservable);\n            if (this.durationSelector) {\n                let duration;\n                try {\n                    duration = this.durationSelector(new GroupedObservable(key, group));\n                }\n                catch (err) {\n                    this.error(err);\n                    return;\n                }\n                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));\n            }\n        }\n        if (!group.closed) {\n            group.next(element);\n        }\n    }\n    _error(err) {\n        const groups = this.groups;\n        if (groups) {\n            groups.forEach((group, key) => {\n                group.error(err);\n            });\n            groups.clear();\n        }\n        this.destination.error(err);\n    }\n    _complete() {\n        const groups = this.groups;\n        if (groups) {\n            groups.forEach((group, key) => {\n                group.complete();\n            });\n            groups.clear();\n        }\n        this.destination.complete();\n    }\n    removeGroup(key) {\n        this.groups.delete(key);\n    }\n    unsubscribe() {\n        if (!this.closed) {\n            this.attemptedToUnsubscribe = true;\n            if (this.count === 0) {\n                super.unsubscribe();\n            }\n        }\n    }\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass GroupDurationSubscriber extends Subscriber {\n    constructor(key, group, parent) {\n        super(group);\n        this.key = key;\n        this.group = group;\n        this.parent = parent;\n    }\n    _next(value) {\n        this.complete();\n    }\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _unsubscribe() {\n        const { parent, key } = this;\n        this.key = this.parent = null;\n        if (parent) {\n            parent.removeGroup(key);\n        }\n    }\n}\n/**\n * An Observable representing values belonging to the same group represented by\n * a common key. The values emitted by a GroupedObservable come from the source\n * Observable. The common key is available as the field `key` on a\n * GroupedObservable instance.\n *\n * @class GroupedObservable<K, T>\n */\nexport class GroupedObservable extends Observable {\n    /** @deprecated Do not construct this type. Internal use only */\n    constructor(key, groupSubject, refCountSubscription) {\n        super();\n        this.key = key;\n        this.groupSubject = groupSubject;\n        this.refCountSubscription = refCountSubscription;\n    }\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _subscribe(subscriber) {\n        const subscription = new Subscription();\n        const { refCountSubscription, groupSubject } = this;\n        if (refCountSubscription && !refCountSubscription.closed) {\n            subscription.add(new InnerRefCountSubscription(refCountSubscription));\n        }\n        subscription.add(groupSubject.subscribe(subscriber));\n        return subscription;\n    }\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass InnerRefCountSubscription extends Subscription {\n    constructor(parent) {\n        super();\n        this.parent = parent;\n        parent.count++;\n    }\n    unsubscribe() {\n        const parent = this.parent;\n        if (!parent.closed && !this.closed) {\n            super.unsubscribe();\n            parent.count -= 1;\n            if (parent.count === 0 && parent.attemptedToUnsubscribe) {\n                parent.unsubscribe();\n            }\n        }\n    }\n}\n//# sourceMappingURL=groupBy.js.map"]},"metadata":{},"sourceType":"module"}