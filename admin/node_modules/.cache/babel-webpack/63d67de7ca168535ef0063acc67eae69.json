{"ast":null,"code":"import _inherits from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Subscriber } from '../Subscriber';\nimport { Notification } from '../Notification';\n/**\n *\n * Re-emits all notifications from source Observable with specified scheduler.\n *\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n *\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n *\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n * little bit more, to ensure that they are emitted at expected moments.\n *\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n * will delay all notifications - including error notifications - while `delay` will pass through error\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n * for notification emissions in general.\n *\n * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>\n * const intervals = Rx.Observable.interval(10); // Intervals are scheduled\n *                                               // with async scheduler by default...\n *\n * intervals\n * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame\n * .subscribe(val => {                           // scheduler to ensure smooth animation.\n *   someDiv.style.height = val + 'px';\n * });\n *\n * @see {@link delay}\n *\n * @param {SchedulerLike} scheduler Scheduler that will be used to reschedule notifications from source Observable.\n * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.\n * @return {Observable<T>} Observable that emits the same notifications as the source Observable,\n * but with provided scheduler.\n *\n * @method observeOn\n * @owner Observable\n */\n\nexport function observeOn(scheduler) {\n  var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return function observeOnOperatorFunction(source) {\n    return source.lift(new ObserveOnOperator(scheduler, delay));\n  };\n}\nexport var ObserveOnOperator = /*#__PURE__*/function () {\n  function ObserveOnOperator(scheduler) {\n    var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, ObserveOnOperator);\n\n    this.scheduler = scheduler;\n    this.delay = delay;\n  }\n\n  _createClass(ObserveOnOperator, [{\n    key: \"call\",\n    value: function call(subscriber, source) {\n      return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n    }\n  }]);\n\n  return ObserveOnOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nexport var ObserveOnSubscriber = /*#__PURE__*/function (_Subscriber) {\n  _inherits(ObserveOnSubscriber, _Subscriber);\n\n  var _super = _createSuper(ObserveOnSubscriber);\n\n  function ObserveOnSubscriber(destination, scheduler) {\n    var _this;\n\n    var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    _classCallCheck(this, ObserveOnSubscriber);\n\n    _this = _super.call(this, destination);\n    _this.scheduler = scheduler;\n    _this.delay = delay;\n    return _this;\n  }\n  /** @nocollapse */\n\n\n  _createClass(ObserveOnSubscriber, [{\n    key: \"scheduleMessage\",\n    value: function scheduleMessage(notification) {\n      this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));\n    }\n  }, {\n    key: \"_next\",\n    value: function _next(value) {\n      this.scheduleMessage(Notification.createNext(value));\n    }\n  }, {\n    key: \"_error\",\n    value: function _error(err) {\n      this.scheduleMessage(Notification.createError(err));\n    }\n  }, {\n    key: \"_complete\",\n    value: function _complete() {\n      this.scheduleMessage(Notification.createComplete());\n    }\n  }], [{\n    key: \"dispatch\",\n    value: function dispatch(arg) {\n      var notification = arg.notification,\n          destination = arg.destination;\n      notification.observe(destination);\n      this.unsubscribe();\n    }\n  }]);\n\n  return ObserveOnSubscriber;\n}(Subscriber);\nexport var ObserveOnMessage = function ObserveOnMessage(notification, destination) {\n  _classCallCheck(this, ObserveOnMessage);\n\n  this.notification = notification;\n  this.destination = destination;\n};","map":null,"metadata":{},"sourceType":"module"}