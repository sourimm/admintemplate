{"ast":null,"code":"import _classCallCheck from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _toConsumableArray from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { Observable } from '../Observable';\nimport { isArray } from '../util/isArray';\nimport { EMPTY } from './empty';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { map } from '../operators/map';\n/* tslint:enable:max-line-length */\n\n/**\n * Joins last values emitted by passed Observables.\n *\n * <span class=\"informal\">Wait for Observables to complete and then combine last values they emitted.</span>\n *\n * <img src=\"./img/forkJoin.png\" width=\"100%\">\n *\n * `forkJoin` is an operator that takes any number of Observables which can be passed either as an array\n * or directly as arguments. If no input Observables are provided, resulting stream will complete\n * immediately.\n *\n * `forkJoin` will wait for all passed Observables to complete and then it will emit an array with last\n * values from corresponding Observables. So if you pass `n` Observables to the operator, resulting\n * array will have `n` values, where first value is the last thing emitted by the first Observable,\n * second value is the last thing emitted by the second Observable and so on. That means `forkJoin` will\n * not emit more than once and it will complete after that. If you need to emit combined values not only\n * at the end of lifecycle of passed Observables, but also throughout it, try out {@link combineLatest}\n * or {@link zip} instead.\n *\n * In order for resulting array to have the same length as the number of input Observables, whenever any of\n * that Observables completes without emitting any value, `forkJoin` will complete at that moment as well\n * and it will not emit anything either, even if it already has some last values from other Observables.\n * Conversely, if there is an Observable that never completes, `forkJoin` will never complete as well,\n * unless at any point some other Observable completes without emitting value, which brings us back to\n * the previous case. Overall, in order for `forkJoin` to emit a value, all Observables passed as arguments\n * have to emit something at least once and complete.\n *\n * If any input Observable errors at some point, `forkJoin` will error as well and all other Observables\n * will be immediately unsubscribed.\n *\n * Optionally `forkJoin` accepts project function, that will be called with values which normally\n * would land in emitted array. Whatever is returned by project function, will appear in output\n * Observable instead. This means that default project can be thought of as a function that takes\n * all its arguments and puts them into an array. Note that project function will be called only\n * when output Observable is supposed to emit a result.\n *\n * @example <caption>Use forkJoin with operator emitting immediately</caption>\n * import { forkJoin, of } from 'rxjs';\n *\n * const observable = forkJoin(\n *   of(1, 2, 3, 4),\n *   of(5, 6, 7, 8)\n * );\n * observable.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('This is how it ends!')\n * );\n *\n * // Logs:\n * // [4, 8]\n * // \"This is how it ends!\"\n *\n *\n * @example <caption>Use forkJoin with operator emitting after some time</caption>\n * import { forkJoin, interval } from 'rxjs';\n * import { take } from 'rxjs/operators';\n *\n * const observable = forkJoin(\n *   interval(1000).pipe(take(3)), // emit 0, 1, 2 every second and complete\n *   interval(500).pipe(take(4)) // emit 0, 1, 2, 3 every half a second and complete\n * );\n * observable.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('This is how it ends!')\n * );\n *\n * // Logs:\n * // [2, 3] after 3 seconds\n * // \"This is how it ends!\" immediately after\n *\n *\n * @example <caption>Use forkJoin with project function</caption>\n * import { jorkJoin, interval } from 'rxjs';\n * import { take } from 'rxjs/operators';\n *\n * const observable = forkJoin(\n *   interval(1000).pipe(take(3)), // emit 0, 1, 2 every second and complete\n *   interval(500).pipe(take(4)), // emit 0, 1, 2, 3 every half a second and complete\n *   (n, m) => n + m\n * );\n * observable.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('This is how it ends!')\n * );\n *\n * // Logs:\n * // 5 after 3 seconds\n * // \"This is how it ends!\" immediately after\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n *\n * @param {...ObservableInput} sources Any number of Observables provided either as an array or as an arguments\n * passed directly to the operator.\n * @param {function} [project] Function that takes values emitted by input Observables and returns value\n * that will appear in resulting Observable instead of default array.\n * @return {Observable} Observable emitting either an array of last values emitted by passed Observables\n * or value from project function.\n */\n\nexport function forkJoin() {\n  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n    sources[_key] = arguments[_key];\n  }\n\n  var resultSelector;\n\n  if (typeof sources[sources.length - 1] === 'function') {\n    // DEPRECATED PATH\n    resultSelector = sources.pop();\n  } // if the first and only other argument is an array\n  // assume it's been called with `forkJoin([obs1, obs2, obs3])`\n\n\n  if (sources.length === 1 && isArray(sources[0])) {\n    sources = sources[0];\n  }\n\n  if (sources.length === 0) {\n    return EMPTY;\n  }\n\n  if (resultSelector) {\n    // DEPRECATED PATH\n    return forkJoin(sources).pipe(map(function (args) {\n      return resultSelector.apply(void 0, _toConsumableArray(args));\n    }));\n  }\n\n  return new Observable(function (subscriber) {\n    return new ForkJoinSubscriber(subscriber, sources);\n  });\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nvar ForkJoinSubscriber = /*#__PURE__*/function (_OuterSubscriber) {\n  _inherits(ForkJoinSubscriber, _OuterSubscriber);\n\n  var _super = _createSuper(ForkJoinSubscriber);\n\n  function ForkJoinSubscriber(destination, sources) {\n    var _this;\n\n    _classCallCheck(this, ForkJoinSubscriber);\n\n    _this = _super.call(this, destination);\n    _this.sources = sources;\n    _this.completed = 0;\n    _this.haveValues = 0;\n    var len = sources.length;\n    _this.values = new Array(len);\n\n    for (var i = 0; i < len; i++) {\n      var source = sources[i];\n      var innerSubscription = subscribeToResult(_assertThisInitialized(_this), source, null, i);\n\n      if (innerSubscription) {\n        _this.add(innerSubscription);\n      }\n    }\n\n    return _this;\n  }\n\n  _createClass(ForkJoinSubscriber, [{\n    key: \"notifyNext\",\n    value: function notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n      this.values[outerIndex] = innerValue;\n\n      if (!innerSub._hasValue) {\n        innerSub._hasValue = true;\n        this.haveValues++;\n      }\n    }\n  }, {\n    key: \"notifyComplete\",\n    value: function notifyComplete(innerSub) {\n      var destination = this.destination,\n          haveValues = this.haveValues,\n          values = this.values;\n      var len = values.length;\n\n      if (!innerSub._hasValue) {\n        destination.complete();\n        return;\n      }\n\n      this.completed++;\n\n      if (this.completed !== len) {\n        return;\n      }\n\n      if (haveValues === len) {\n        destination.next(values);\n      }\n\n      destination.complete();\n    }\n  }]);\n\n  return ForkJoinSubscriber;\n}(OuterSubscriber);","map":{"version":3,"sources":["../../../src/internal/observable/forkJoin.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observable } from '../Observable';\nimport { isArray } from '../util/isArray';\nimport { EMPTY } from './empty';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { map } from '../operators/map';\n/* tslint:enable:max-line-length */\n/**\n * Joins last values emitted by passed Observables.\n *\n * <span class=\"informal\">Wait for Observables to complete and then combine last values they emitted.</span>\n *\n * <img src=\"./img/forkJoin.png\" width=\"100%\">\n *\n * `forkJoin` is an operator that takes any number of Observables which can be passed either as an array\n * or directly as arguments. If no input Observables are provided, resulting stream will complete\n * immediately.\n *\n * `forkJoin` will wait for all passed Observables to complete and then it will emit an array with last\n * values from corresponding Observables. So if you pass `n` Observables to the operator, resulting\n * array will have `n` values, where first value is the last thing emitted by the first Observable,\n * second value is the last thing emitted by the second Observable and so on. That means `forkJoin` will\n * not emit more than once and it will complete after that. If you need to emit combined values not only\n * at the end of lifecycle of passed Observables, but also throughout it, try out {@link combineLatest}\n * or {@link zip} instead.\n *\n * In order for resulting array to have the same length as the number of input Observables, whenever any of\n * that Observables completes without emitting any value, `forkJoin` will complete at that moment as well\n * and it will not emit anything either, even if it already has some last values from other Observables.\n * Conversely, if there is an Observable that never completes, `forkJoin` will never complete as well,\n * unless at any point some other Observable completes without emitting value, which brings us back to\n * the previous case. Overall, in order for `forkJoin` to emit a value, all Observables passed as arguments\n * have to emit something at least once and complete.\n *\n * If any input Observable errors at some point, `forkJoin` will error as well and all other Observables\n * will be immediately unsubscribed.\n *\n * Optionally `forkJoin` accepts project function, that will be called with values which normally\n * would land in emitted array. Whatever is returned by project function, will appear in output\n * Observable instead. This means that default project can be thought of as a function that takes\n * all its arguments and puts them into an array. Note that project function will be called only\n * when output Observable is supposed to emit a result.\n *\n * @example <caption>Use forkJoin with operator emitting immediately</caption>\n * import { forkJoin, of } from 'rxjs';\n *\n * const observable = forkJoin(\n *   of(1, 2, 3, 4),\n *   of(5, 6, 7, 8)\n * );\n * observable.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('This is how it ends!')\n * );\n *\n * // Logs:\n * // [4, 8]\n * // \"This is how it ends!\"\n *\n *\n * @example <caption>Use forkJoin with operator emitting after some time</caption>\n * import { forkJoin, interval } from 'rxjs';\n * import { take } from 'rxjs/operators';\n *\n * const observable = forkJoin(\n *   interval(1000).pipe(take(3)), // emit 0, 1, 2 every second and complete\n *   interval(500).pipe(take(4)) // emit 0, 1, 2, 3 every half a second and complete\n * );\n * observable.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('This is how it ends!')\n * );\n *\n * // Logs:\n * // [2, 3] after 3 seconds\n * // \"This is how it ends!\" immediately after\n *\n *\n * @example <caption>Use forkJoin with project function</caption>\n * import { jorkJoin, interval } from 'rxjs';\n * import { take } from 'rxjs/operators';\n *\n * const observable = forkJoin(\n *   interval(1000).pipe(take(3)), // emit 0, 1, 2 every second and complete\n *   interval(500).pipe(take(4)), // emit 0, 1, 2, 3 every half a second and complete\n *   (n, m) => n + m\n * );\n * observable.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('This is how it ends!')\n * );\n *\n * // Logs:\n * // 5 after 3 seconds\n * // \"This is how it ends!\" immediately after\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n *\n * @param {...ObservableInput} sources Any number of Observables provided either as an array or as an arguments\n * passed directly to the operator.\n * @param {function} [project] Function that takes values emitted by input Observables and returns value\n * that will appear in resulting Observable instead of default array.\n * @return {Observable} Observable emitting either an array of last values emitted by passed Observables\n * or value from project function.\n */\nexport function forkJoin(...sources) {\n    let resultSelector;\n    if (typeof sources[sources.length - 1] === 'function') {\n        // DEPRECATED PATH\n        resultSelector = sources.pop();\n    }\n    // if the first and only other argument is an array\n    // assume it's been called with `forkJoin([obs1, obs2, obs3])`\n    if (sources.length === 1 && isArray(sources[0])) {\n        sources = sources[0];\n    }\n    if (sources.length === 0) {\n        return EMPTY;\n    }\n    if (resultSelector) {\n        // DEPRECATED PATH\n        return forkJoin(sources).pipe(map(args => resultSelector(...args)));\n    }\n    return new Observable(subscriber => {\n        return new ForkJoinSubscriber(subscriber, sources);\n    });\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass ForkJoinSubscriber extends OuterSubscriber {\n    constructor(destination, sources) {\n        super(destination);\n        this.sources = sources;\n        this.completed = 0;\n        this.haveValues = 0;\n        const len = sources.length;\n        this.values = new Array(len);\n        for (let i = 0; i < len; i++) {\n            const source = sources[i];\n            const innerSubscription = subscribeToResult(this, source, null, i);\n            if (innerSubscription) {\n                this.add(innerSubscription);\n            }\n        }\n    }\n    notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.values[outerIndex] = innerValue;\n        if (!innerSub._hasValue) {\n            innerSub._hasValue = true;\n            this.haveValues++;\n        }\n    }\n    notifyComplete(innerSub) {\n        const { destination, haveValues, values } = this;\n        const len = values.length;\n        if (!innerSub._hasValue) {\n            destination.complete();\n            return;\n        }\n        this.completed++;\n        if (this.completed !== len) {\n            return;\n        }\n        if (haveValues === len) {\n            destination.next(values);\n        }\n        destination.complete();\n    }\n}\n//# sourceMappingURL=forkJoin.js.map"]},"metadata":{},"sourceType":"module"}