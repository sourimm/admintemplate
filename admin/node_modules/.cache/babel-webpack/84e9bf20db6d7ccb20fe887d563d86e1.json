{"ast":null,"code":"\"use strict\";\n\nvar ɵngcc0 = require('@angular/core');\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar dragula_class_1 = require(\"./dragula.class\");\n\nvar core_1 = require(\"@angular/core\");\n\nvar DragulaService = /*@__PURE__*/function () {\n  function DragulaService() {\n    this.cancel = new core_1.EventEmitter();\n    this.cloned = new core_1.EventEmitter();\n    this.drag = new core_1.EventEmitter();\n    this.dragend = new core_1.EventEmitter();\n    this.drop = new core_1.EventEmitter();\n    this.out = new core_1.EventEmitter();\n    this.over = new core_1.EventEmitter();\n    this.remove = new core_1.EventEmitter();\n    this.shadow = new core_1.EventEmitter();\n    this.dropModel = new core_1.EventEmitter();\n    this.removeModel = new core_1.EventEmitter();\n    this.events = ['cancel', 'cloned', 'drag', 'dragend', 'drop', 'out', 'over', 'remove', 'shadow', 'dropModel', 'removeModel'];\n    this.bags = [];\n  }\n\n  DragulaService.prototype.add = function (name, drake) {\n    var bag = this.find(name);\n\n    if (bag) {\n      throw new Error('Bag named: \"' + name + '\" already exists.');\n    }\n\n    bag = {\n      name: name,\n      drake: drake\n    };\n    this.bags.push(bag);\n\n    if (drake.models) {\n      this.handleModels(name, drake);\n    }\n\n    if (!bag.initEvents) {\n      this.setupEvents(bag);\n    }\n\n    return bag;\n  };\n\n  DragulaService.prototype.find = function (name) {\n    for (var _i = 0, _a = this.bags; _i < _a.length; _i++) {\n      var bag = _a[_i];\n\n      if (bag.name === name) {\n        return bag;\n      }\n    }\n  };\n\n  DragulaService.prototype.destroy = function (name) {\n    var bag = this.find(name);\n    var i = this.bags.indexOf(bag);\n    this.bags.splice(i, 1);\n    bag.drake.destroy();\n  };\n\n  DragulaService.prototype.setOptions = function (name, options) {\n    var bag = this.add(name, dragula_class_1.dragula(options));\n    this.handleModels(name, bag.drake);\n  };\n\n  DragulaService.prototype.handleModels = function (name, drake) {\n    var _this = this;\n\n    var dragElm;\n    var dragIndex;\n    var dropIndex;\n    var sourceModel;\n    drake.on('remove', function (el, source) {\n      if (!drake.models) {\n        return;\n      }\n\n      sourceModel = drake.models[drake.containers.indexOf(source)];\n      sourceModel.splice(dragIndex, 1); // console.log('REMOVE');\n      // console.log(sourceModel);\n\n      _this.removeModel.emit([name, el, source]);\n    });\n    drake.on('drag', function (el, source) {\n      dragElm = el;\n      dragIndex = _this.domIndexOf(el, source);\n    });\n    drake.on('drop', function (dropElm, target, source) {\n      if (!drake.models || !target) {\n        return;\n      }\n\n      dropIndex = _this.domIndexOf(dropElm, target);\n      sourceModel = drake.models[drake.containers.indexOf(source)]; // console.log('DROP');\n      // console.log(sourceModel);\n\n      if (target === source) {\n        sourceModel.splice(dropIndex, 0, sourceModel.splice(dragIndex, 1)[0]);\n      } else {\n        var notCopy = dragElm === dropElm;\n        var targetModel = drake.models[drake.containers.indexOf(target)];\n        var dropElmModel = notCopy ? sourceModel[dragIndex] : JSON.parse(JSON.stringify(sourceModel[dragIndex]));\n\n        if (notCopy) {\n          sourceModel.splice(dragIndex, 1);\n        }\n\n        targetModel.splice(dropIndex, 0, dropElmModel);\n        target.removeChild(dropElm); // element must be removed for ngFor to apply correctly\n      }\n\n      _this.dropModel.emit([name, dropElm, target, source]);\n    });\n  };\n\n  DragulaService.prototype.setupEvents = function (bag) {\n    bag.initEvents = true;\n    var that = this;\n\n    var emitter = function emitter(type) {\n      function replicate() {\n        var args = Array.prototype.slice.call(arguments);\n        that[type].emit([bag.name].concat(args));\n      }\n\n      bag.drake.on(type, replicate);\n    };\n\n    this.events.forEach(emitter);\n  };\n\n  DragulaService.prototype.domIndexOf = function (child, parent) {\n    return Array.prototype.indexOf.call(parent.children, child);\n  };\n\n  DragulaService.ɵfac = function DragulaService_Factory(t) {\n    return new (t || DragulaService)();\n  };\n\n  DragulaService.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n    token: DragulaService,\n    factory: function factory(t) {\n      return DragulaService.ɵfac(t);\n    }\n  });\n  return DragulaService;\n}();\n\nexports.DragulaService = DragulaService;","map":null,"metadata":{},"sourceType":"script"}