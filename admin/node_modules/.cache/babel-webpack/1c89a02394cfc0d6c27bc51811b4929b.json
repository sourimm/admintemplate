{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar core_1 = require(\"@angular/core\");\n\nvar forms_1 = require(\"@angular/forms\");\n\nvar platform_browser_1 = require(\"@angular/platform-browser\");\n\nvar textMaskCore_1 = require(\"text-mask-core/dist/textMaskCore\");\n\nvar ɵngcc0 = require('@angular/core');\n\nvar TextMaskConfig =\n/** @class */\nfunction () {\n  function TextMaskConfig() {}\n\n  return TextMaskConfig;\n}();\n\nexports.TextMaskConfig = TextMaskConfig;\nexports.MASKEDINPUT_VALUE_ACCESSOR = {\n  provide: forms_1.NG_VALUE_ACCESSOR,\n  useExisting: core_1.forwardRef(function () {\n    return MaskedInputDirective;\n  }),\n  multi: true\n};\n/**\n * We must check whether the agent is Android because composition events\n * behave differently between iOS and Android.\n */\n\nfunction _isAndroid() {\n  var userAgent = platform_browser_1.ɵgetDOM() ? platform_browser_1.ɵgetDOM().getUserAgent() : '';\n  return /android (\\d+)/.test(userAgent.toLowerCase());\n}\n\nvar MaskedInputDirective =\n/** @class */\nfunction () {\n  function MaskedInputDirective(_renderer, _elementRef, _compositionMode) {\n    this._renderer = _renderer;\n    this._elementRef = _elementRef;\n    this._compositionMode = _compositionMode;\n    this.textMaskConfig = {\n      mask: [],\n      guide: true,\n      placeholderChar: '_',\n      pipe: undefined,\n      keepCharPositions: false\n    };\n\n    this.onChange = function (_) {};\n\n    this.onTouched = function () {};\n    /** Whether the user is creating a composition string (IME events). */\n\n\n    this._composing = false;\n\n    if (this._compositionMode == null) {\n      this._compositionMode = !_isAndroid();\n    }\n  }\n\n  MaskedInputDirective.prototype.ngOnChanges = function (changes) {\n    this._setupMask(true);\n\n    if (this.textMaskInputElement !== undefined) {\n      this.textMaskInputElement.update(this.inputElement.value);\n    }\n  };\n\n  MaskedInputDirective.prototype.writeValue = function (value) {\n    this._setupMask(); // set the initial value for cases where the mask is disabled\n\n\n    var normalizedValue = value == null ? '' : value;\n\n    this._renderer.setProperty(this.inputElement, 'value', normalizedValue);\n\n    if (this.textMaskInputElement !== undefined) {\n      this.textMaskInputElement.update(value);\n    }\n  };\n\n  MaskedInputDirective.prototype.registerOnChange = function (fn) {\n    this.onChange = fn;\n  };\n\n  MaskedInputDirective.prototype.registerOnTouched = function (fn) {\n    this.onTouched = fn;\n  };\n\n  MaskedInputDirective.prototype.setDisabledState = function (isDisabled) {\n    this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n  };\n\n  MaskedInputDirective.prototype._handleInput = function (value) {\n    if (!this._compositionMode || this._compositionMode && !this._composing) {\n      this._setupMask();\n\n      if (this.textMaskInputElement !== undefined) {\n        this.textMaskInputElement.update(value); // get the updated value\n\n        value = this.inputElement.value;\n        this.onChange(value);\n      }\n    }\n  };\n\n  MaskedInputDirective.prototype._setupMask = function (create) {\n    if (create === void 0) {\n      create = false;\n    }\n\n    if (!this.inputElement) {\n      if (this._elementRef.nativeElement.tagName.toUpperCase() === 'INPUT') {\n        // `textMask` directive is used directly on an input element\n        this.inputElement = this._elementRef.nativeElement;\n      } else {\n        // `textMask` directive is used on an abstracted input element, `md-input-container`, etc\n        this.inputElement = this._elementRef.nativeElement.getElementsByTagName('INPUT')[0];\n      }\n    }\n\n    if (this.inputElement && create) {\n      this.textMaskInputElement = textMaskCore_1.createTextMaskInputElement(Object.assign({\n        inputElement: this.inputElement\n      }, this.textMaskConfig));\n    }\n  };\n\n  MaskedInputDirective.prototype._compositionStart = function () {\n    this._composing = true;\n  };\n\n  MaskedInputDirective.prototype._compositionEnd = function (value) {\n    this._composing = false;\n    this._compositionMode && this._handleInput(value);\n  };\n  /** @nocollapse */\n\n\n  MaskedInputDirective.ctorParameters = function () {\n    return [{\n      type: core_1.Renderer2\n    }, {\n      type: core_1.ElementRef\n    }, {\n      type: undefined,\n      decorators: [{\n        type: core_1.Optional\n      }, {\n        type: core_1.Inject,\n        args: [forms_1.COMPOSITION_BUFFER_MODE]\n      }]\n    }];\n  };\n\n  MaskedInputDirective.propDecorators = {\n    'textMaskConfig': [{\n      type: core_1.Input,\n      args: ['textMask']\n    }]\n  };\n\n  MaskedInputDirective.ɵfac = function MaskedInputDirective_Factory(t) {\n    return new (t || MaskedInputDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(forms_1.COMPOSITION_BUFFER_MODE, 8));\n  };\n\n  MaskedInputDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n    type: MaskedInputDirective,\n    selectors: [[\"\", \"textMask\", \"\"]],\n    hostBindings: function MaskedInputDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"input\", function MaskedInputDirective_input_HostBindingHandler($event) {\n          return ctx._handleInput($event.target.value);\n        })(\"blur\", function MaskedInputDirective_blur_HostBindingHandler() {\n          return ctx.onTouched();\n        })(\"compositionstart\", function MaskedInputDirective_compositionstart_HostBindingHandler() {\n          return ctx._compositionStart();\n        })(\"compositionend\", function MaskedInputDirective_compositionend_HostBindingHandler($event) {\n          return ctx._compositionEnd($event.target.value);\n        });\n      }\n    },\n    inputs: {\n      textMaskConfig: [\"textMask\", \"textMaskConfig\"]\n    },\n    exportAs: [\"textMask\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([exports.MASKEDINPUT_VALUE_ACCESSOR]), ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  /*@__PURE__*/\n\n  (function () {\n    ɵngcc0.ɵsetClassMetadata(MaskedInputDirective, [{\n      type: core_1.Directive,\n      args: [{\n        host: {\n          '(input)': '_handleInput($event.target.value)',\n          '(blur)': 'onTouched()',\n          '(compositionstart)': '_compositionStart()',\n          '(compositionend)': '_compositionEnd($event.target.value)'\n        },\n        selector: '[textMask]',\n        exportAs: 'textMask',\n        providers: [exports.MASKEDINPUT_VALUE_ACCESSOR]\n      }]\n    }], function () {\n      return [{\n        type: ɵngcc0.Renderer2\n      }, {\n        type: ɵngcc0.ElementRef\n      }, {\n        type: undefined,\n        decorators: [{\n          type: core_1.Optional\n        }, {\n          type: core_1.Inject,\n          args: [forms_1.COMPOSITION_BUFFER_MODE]\n        }]\n      }];\n    }, {\n      textMaskConfig: [{\n        type: core_1.Input,\n        args: ['textMask']\n      }]\n    });\n  })();\n\n  return MaskedInputDirective;\n}();\n\nexports.MaskedInputDirective = MaskedInputDirective;\n\nvar TextMaskModule =\n/** @class */\nfunction () {\n  function TextMaskModule() {}\n  /** @nocollapse */\n\n\n  TextMaskModule.ctorParameters = function () {\n    return [];\n  };\n\n  TextMaskModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n    type: TextMaskModule\n  });\n  TextMaskModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n    factory: function TextMaskModule_Factory(t) {\n      return new (t || TextMaskModule)();\n    }\n  });\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TextMaskModule, {\n      declarations: [MaskedInputDirective],\n      exports: [MaskedInputDirective]\n    });\n  })();\n  /*@__PURE__*/\n\n\n  (function () {\n    ɵngcc0.ɵsetClassMetadata(TextMaskModule, [{\n      type: core_1.NgModule,\n      args: [{\n        declarations: [MaskedInputDirective],\n        exports: [MaskedInputDirective]\n      }]\n    }], function () {\n      return [];\n    }, null);\n  })();\n\n  return TextMaskModule;\n}();\n\nexports.TextMaskModule = TextMaskModule;\n\nvar textMaskCore_2 = require(\"text-mask-core/dist/textMaskCore\");\n\nexports.conformToMask = textMaskCore_2.conformToMask;","map":{"version":3,"sources":["../src/angular2TextMask.ts"],"names":[],"mappings":"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","sourcesContent":["import { Directive, ElementRef, forwardRef, Input, Inject, NgModule, OnChanges, Optional, Provider, Renderer2, SimpleChanges } from '@angular/core'\nimport { NG_VALUE_ACCESSOR, ControlValueAccessor, COMPOSITION_BUFFER_MODE } from '@angular/forms'\nimport {ɵgetDOM as getDOM} from '@angular/platform-browser'\nimport { createTextMaskInputElement } from 'text-mask-core/dist/textMaskCore'\n\nexport class TextMaskConfig {\n  mask: Array<string | RegExp> | ((raw: string) => Array<string | RegExp>) | false\n  guide?: boolean\n  placeholderChar?: string\n  pipe?: (conformedValue: string, config: TextMaskConfig) => false | string | object\n  keepCharPositions?: boolean\n  showMask?: boolean\n}\n\nexport const MASKEDINPUT_VALUE_ACCESSOR: Provider = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MaskedInputDirective),\n  multi: true\n}\n\n/**\n * We must check whether the agent is Android because composition events\n * behave differently between iOS and Android.\n */\nfunction _isAndroid(): boolean {\n  const userAgent = getDOM() ? getDOM().getUserAgent() : ''\n  return /android (\\d+)/.test(userAgent.toLowerCase())\n}\n\n@Directive({\n  host: {\n    '(input)': '_handleInput($event.target.value)',\n    '(blur)': 'onTouched()',\n    '(compositionstart)': '_compositionStart()',\n    '(compositionend)': '_compositionEnd($event.target.value)'\n  },\n  selector: '[textMask]',\n  exportAs: 'textMask',\n  providers: [MASKEDINPUT_VALUE_ACCESSOR]\n})\nexport class MaskedInputDirective implements ControlValueAccessor, OnChanges {\n  @Input('textMask') textMaskConfig: TextMaskConfig = {\n    mask: [],\n    guide: true,\n    placeholderChar: '_',\n    pipe: undefined,\n    keepCharPositions: false,\n  }\n\n  onChange = (_: any) => {}\n  onTouched = () => {}\n\n  private textMaskInputElement: any\n  private inputElement: HTMLInputElement\n\n  /** Whether the user is creating a composition string (IME events). */\n  private _composing = false\n\n  constructor(\n    private _renderer: Renderer2,\n    private _elementRef: ElementRef,\n    @Optional() @Inject(COMPOSITION_BUFFER_MODE)private _compositionMode: boolean\n  ) {\n    if (this._compositionMode == null) {\n      this._compositionMode = !_isAndroid()\n    }\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    this._setupMask(true)\n    if (this.textMaskInputElement !== undefined) {\n      this.textMaskInputElement.update(this.inputElement.value)\n    }\n  }\n\n  writeValue(value: any) {\n    this._setupMask()\n\n    // set the initial value for cases where the mask is disabled\n    const normalizedValue = value == null ? '' : value\n    this._renderer.setProperty(this.inputElement, 'value', normalizedValue)\n\n    if (this.textMaskInputElement !== undefined) {\n      this.textMaskInputElement.update(value)\n    }\n  }\n\n  registerOnChange(fn: (_: any) => void): void { this.onChange = fn }\n  registerOnTouched(fn: () => void): void { this.onTouched = fn }\n\n  setDisabledState(isDisabled: boolean): void {\n    this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled)\n  }\n\n  \n  _handleInput(value) {\n    if (!this._compositionMode || (this._compositionMode && !this._composing)) {\n      this._setupMask()\n\n      if (this.textMaskInputElement !== undefined) {\n        this.textMaskInputElement.update(value)\n        \n        // get the updated value\n        value = this.inputElement.value\n        this.onChange(value)\n      }\n    }\n  }\n\n  _setupMask(create = false) {\n    if (!this.inputElement) {\n      if (this._elementRef.nativeElement.tagName.toUpperCase() === 'INPUT') {\n        // `textMask` directive is used directly on an input element\n        this.inputElement = this._elementRef.nativeElement\n      } else {\n        // `textMask` directive is used on an abstracted input element, `md-input-container`, etc\n        this.inputElement = this._elementRef.nativeElement.getElementsByTagName('INPUT')[0]\n      }\n    }\n    \n    if (this.inputElement && create) {\n      this.textMaskInputElement = createTextMaskInputElement(\n        Object.assign({inputElement: this.inputElement}, this.textMaskConfig)\n      )\n    }\n    \n  }\n\n  _compositionStart(): void { this._composing = true }\n\n  _compositionEnd(value: any): void {\n    this._composing = false\n    this._compositionMode && this._handleInput(value)\n  }\n}\n\n@NgModule({\n  declarations: [MaskedInputDirective],\n  exports: [MaskedInputDirective]\n})\nexport class TextMaskModule {}\n\nexport { conformToMask } from 'text-mask-core/dist/textMaskCore'\n"]},"metadata":{},"sourceType":"script"}