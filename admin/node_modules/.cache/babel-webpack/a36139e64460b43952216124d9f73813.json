{"ast":null,"code":"import _get from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { async } from '../scheduler/async';\nimport { isDate } from '../util/isDate';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n/* tslint:enable:max-line-length */\n\n/**\n *\n * Errors if Observable does not emit a value in given time span, in case of which\n * subscribes to the second Observable.\n *\n * <span class=\"informal\">It's a version of `timeout` operator that let's you specify fallback Observable.</span>\n *\n * <img src=\"./img/timeoutWith.png\" width=\"100%\">\n *\n * `timeoutWith` is a variation of `timeout` operator. It behaves exactly the same,\n * still accepting as a first argument either a number or a Date, which control - respectively -\n * when values of source Observable should be emitted or when it should complete.\n *\n * The only difference is that it accepts a second, required parameter. This parameter\n * should be an Observable which will be subscribed when source Observable fails any timeout check.\n * So whenever regular `timeout` would emit an error, `timeoutWith` will instead start re-emitting\n * values from second Observable. Note that this fallback Observable is not checked for timeouts\n * itself, so it can emit values and complete at arbitrary points in time. From the moment of a second\n * subscription, Observable returned from `timeoutWith` simply mirrors fallback stream. When that\n * stream completes, it completes as well.\n *\n * Scheduler, which in case of `timeout` is provided as as second argument, can be still provided\n * here - as a third, optional parameter. It still is used to schedule timeout checks and -\n * as a consequence - when second Observable will be subscribed, since subscription happens\n * immediately after failing check.\n *\n * @example <caption>Add fallback observable</caption>\n * const seconds = Rx.Observable.interval(1000);\n * const minutes = Rx.Observable.interval(60 * 1000);\n *\n * seconds.timeoutWith(900, minutes)\n *     .subscribe(\n *         value => console.log(value), // After 900ms, will start emitting `minutes`,\n *                                      // since first value of `seconds` will not arrive fast enough.\n *         err => console.log(err) // Would be called after 900ms in case of `timeout`,\n *                                 // but here will never be called.\n *     );\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {Observable<T>} withObservable Observable which will be subscribed if source fails timeout check.\n * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source or, when timeout check fails, of an Observable\n *                          passed as a second parameter.\n * @method timeoutWith\n * @owner Observable\n */\n\nexport function timeoutWith(due, withObservable) {\n  var scheduler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : async;\n  return function (source) {\n    var absoluteTimeout = isDate(due);\n    var waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);\n    return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));\n  };\n}\n\nvar TimeoutWithOperator = /*#__PURE__*/function () {\n  function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {\n    _classCallCheck(this, TimeoutWithOperator);\n\n    this.waitFor = waitFor;\n    this.absoluteTimeout = absoluteTimeout;\n    this.withObservable = withObservable;\n    this.scheduler = scheduler;\n  }\n\n  _createClass(TimeoutWithOperator, [{\n    key: \"call\",\n    value: function call(subscriber, source) {\n      return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));\n    }\n  }]);\n\n  return TimeoutWithOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar TimeoutWithSubscriber = /*#__PURE__*/function (_OuterSubscriber) {\n  _inherits(TimeoutWithSubscriber, _OuterSubscriber);\n\n  var _super = _createSuper(TimeoutWithSubscriber);\n\n  function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {\n    var _this;\n\n    _classCallCheck(this, TimeoutWithSubscriber);\n\n    _this = _super.call(this, destination);\n    _this.absoluteTimeout = absoluteTimeout;\n    _this.waitFor = waitFor;\n    _this.withObservable = withObservable;\n    _this.scheduler = scheduler;\n    _this.action = null;\n\n    _this.scheduleTimeout();\n\n    return _this;\n  }\n\n  _createClass(TimeoutWithSubscriber, [{\n    key: \"scheduleTimeout\",\n    value: function scheduleTimeout() {\n      var action = this.action;\n\n      if (action) {\n        // Recycle the action if we've already scheduled one. All the production\n        // Scheduler Actions mutate their state/delay time and return themeselves.\n        // VirtualActions are immutable, so they create and return a clone. In this\n        // case, we need to set the action reference to the most recent VirtualAction,\n        // to ensure that's the one we clone from next time.\n        this.action = action.schedule(this, this.waitFor);\n      } else {\n        this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));\n      }\n    }\n  }, {\n    key: \"_next\",\n    value: function _next(value) {\n      if (!this.absoluteTimeout) {\n        this.scheduleTimeout();\n      }\n\n      _get(_getPrototypeOf(TimeoutWithSubscriber.prototype), \"_next\", this).call(this, value);\n    }\n    /** @deprecated This is an internal implementation detail, do not use. */\n\n  }, {\n    key: \"_unsubscribe\",\n    value: function _unsubscribe() {\n      this.action = null;\n      this.scheduler = null;\n      this.withObservable = null;\n    }\n  }], [{\n    key: \"dispatchTimeout\",\n    value: function dispatchTimeout(subscriber) {\n      var withObservable = subscriber.withObservable;\n\n      subscriber._unsubscribeAndRecycle();\n\n      subscriber.add(subscribeToResult(subscriber, withObservable));\n    }\n  }]);\n\n  return TimeoutWithSubscriber;\n}(OuterSubscriber);","map":{"version":3,"sources":["../../../src/internal/operators/timeoutWith.ts"],"names":[],"mappings":";;;;;;AAEA,SAAS,KAAT,QAAsB,oBAAtB;AAEA,SAAS,MAAT,QAAuB,gBAAvB;AACA,SAAS,eAAT,QAAgC,oBAAhC;AACA,SAAS,iBAAT,QAAkC,2BAAlC;AAKA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+CA,OAAM,SAAA,WAAA,CAA4B,GAA5B,EAC4B,cAD5B,EAE4D;AAAA,MAAhC,SAAgC,uEAAL,KAAK;AAChE,SAAO,UAAC,MAAD,EAA0B;AAC/B,QAAI,eAAe,GAAG,MAAM,CAAC,GAAD,CAA5B;AACA,QAAI,OAAO,GAAG,eAAe,GAAI,CAAC,GAAD,GAAO,SAAS,CAAC,GAAV,EAAX,GAA8B,IAAI,CAAC,GAAL,CAAiB,GAAjB,CAA3D;AACA,WAAO,MAAM,CAAC,IAAP,CAAY,IAAI,mBAAJ,CAAwB,OAAxB,EAAiC,eAAjC,EAAkD,cAAlD,EAAkE,SAAlE,CAAZ,CAAP;AACD,GAJD;AAKD;;IAED,mB;AACE,+BAAoB,OAApB,EACoB,eADpB,EAEoB,cAFpB,EAGoB,SAHpB,EAG4C;AAAA;;AAHxB,SAAA,OAAA,GAAA,OAAA;AACA,SAAA,eAAA,GAAA,eAAA;AACA,SAAA,cAAA,GAAA,cAAA;AACA,SAAA,SAAA,GAAA,SAAA;AACnB;;;;yBAEI,U,EAA2B,M,EAAW;AACzC,aAAO,MAAM,CAAC,SAAP,CAAiB,IAAI,qBAAJ,CACtB,UADsB,EACV,KAAK,eADK,EACY,KAAK,OADjB,EAC0B,KAAK,cAD/B,EAC+C,KAAK,SADpD,CAAjB,CAAP;AAGD;;;;;AAGH;;;;;;;IAKA,qB;;;;;AAIE,iCAAY,WAAZ,EACoB,eADpB,EAEoB,OAFpB,EAGoB,cAHpB,EAIoB,SAJpB,EAI4C;AAAA;;AAAA;;AAC1C,8BAAM,WAAN;AAJkB,UAAA,eAAA,GAAA,eAAA;AACA,UAAA,OAAA,GAAA,OAAA;AACA,UAAA,cAAA,GAAA,cAAA;AACA,UAAA,SAAA,GAAA,SAAA;AANZ,UAAA,MAAA,GAAuD,IAAvD;;AAQN,UAAK,eAAL;;AAF0C;AAG3C;;;;sCAQsB;AAAA,UACb,MADa,GACF,IADE,CACb,MADa;;AAErB,UAAI,MAAJ,EAAY;AACV;AACA;AACA;AACA;AACA;AACA,aAAK,MAAL,GAA8D,MAAM,CAAC,QAAP,CAAgB,IAAhB,EAAsB,KAAK,OAA3B,CAA9D;AACD,OAPD,MAOO;AACL,aAAK,GAAL,CAAS,KAAK,MAAL,GAA8D,KAAK,SAAL,CAAe,QAAf,CACrE,qBAAqB,CAAC,eAD+C,EAC9B,KAAK,OADyB,EAChB,IADgB,CAAvE;AAGD;AACF;;;0BAEe,K,EAAQ;AACtB,UAAI,CAAC,KAAK,eAAV,EAA2B;AACzB,aAAK,eAAL;AACD;;AACD,uFAAY,KAAZ;AACD;AAED;;;;mCACY;AACV,WAAK,MAAL,GAAc,IAAd;AACA,WAAK,SAAL,GAAiB,IAAjB;AACA,WAAK,cAAL,GAAsB,IAAtB;AACD;;;oCAlCoC,U,EAAuC;AAAA,UAClE,cADkE,GAC/C,UAD+C,CAClE,cADkE;;AAEnE,MAAA,UAAW,CAAC,sBAAZ;;AACP,MAAA,UAAU,CAAC,GAAX,CAAe,iBAAiB,CAAC,UAAD,EAAa,cAAb,CAAhC;AACD;;;;EAjBuC,e","sourcesContent":["import { async } from '../scheduler/async';\nimport { isDate } from '../util/isDate';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n/* tslint:enable:max-line-length */\n/**\n *\n * Errors if Observable does not emit a value in given time span, in case of which\n * subscribes to the second Observable.\n *\n * <span class=\"informal\">It's a version of `timeout` operator that let's you specify fallback Observable.</span>\n *\n * <img src=\"./img/timeoutWith.png\" width=\"100%\">\n *\n * `timeoutWith` is a variation of `timeout` operator. It behaves exactly the same,\n * still accepting as a first argument either a number or a Date, which control - respectively -\n * when values of source Observable should be emitted or when it should complete.\n *\n * The only difference is that it accepts a second, required parameter. This parameter\n * should be an Observable which will be subscribed when source Observable fails any timeout check.\n * So whenever regular `timeout` would emit an error, `timeoutWith` will instead start re-emitting\n * values from second Observable. Note that this fallback Observable is not checked for timeouts\n * itself, so it can emit values and complete at arbitrary points in time. From the moment of a second\n * subscription, Observable returned from `timeoutWith` simply mirrors fallback stream. When that\n * stream completes, it completes as well.\n *\n * Scheduler, which in case of `timeout` is provided as as second argument, can be still provided\n * here - as a third, optional parameter. It still is used to schedule timeout checks and -\n * as a consequence - when second Observable will be subscribed, since subscription happens\n * immediately after failing check.\n *\n * @example <caption>Add fallback observable</caption>\n * const seconds = Rx.Observable.interval(1000);\n * const minutes = Rx.Observable.interval(60 * 1000);\n *\n * seconds.timeoutWith(900, minutes)\n *     .subscribe(\n *         value => console.log(value), // After 900ms, will start emitting `minutes`,\n *                                      // since first value of `seconds` will not arrive fast enough.\n *         err => console.log(err) // Would be called after 900ms in case of `timeout`,\n *                                 // but here will never be called.\n *     );\n *\n * @param {number|Date} due Number specifying period within which Observable must emit values\n *                          or Date specifying before when Observable should complete\n * @param {Observable<T>} withObservable Observable which will be subscribed if source fails timeout check.\n * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n * @return {Observable<T>} Observable that mirrors behaviour of source or, when timeout check fails, of an Observable\n *                          passed as a second parameter.\n * @method timeoutWith\n * @owner Observable\n */\nexport function timeoutWith(due, withObservable, scheduler = async) {\n    return (source) => {\n        let absoluteTimeout = isDate(due);\n        let waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);\n        return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));\n    };\n}\nclass TimeoutWithOperator {\n    constructor(waitFor, absoluteTimeout, withObservable, scheduler) {\n        this.waitFor = waitFor;\n        this.absoluteTimeout = absoluteTimeout;\n        this.withObservable = withObservable;\n        this.scheduler = scheduler;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));\n    }\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TimeoutWithSubscriber extends OuterSubscriber {\n    constructor(destination, absoluteTimeout, waitFor, withObservable, scheduler) {\n        super(destination);\n        this.absoluteTimeout = absoluteTimeout;\n        this.waitFor = waitFor;\n        this.withObservable = withObservable;\n        this.scheduler = scheduler;\n        this.action = null;\n        this.scheduleTimeout();\n    }\n    static dispatchTimeout(subscriber) {\n        const { withObservable } = subscriber;\n        subscriber._unsubscribeAndRecycle();\n        subscriber.add(subscribeToResult(subscriber, withObservable));\n    }\n    scheduleTimeout() {\n        const { action } = this;\n        if (action) {\n            // Recycle the action if we've already scheduled one. All the production\n            // Scheduler Actions mutate their state/delay time and return themeselves.\n            // VirtualActions are immutable, so they create and return a clone. In this\n            // case, we need to set the action reference to the most recent VirtualAction,\n            // to ensure that's the one we clone from next time.\n            this.action = action.schedule(this, this.waitFor);\n        }\n        else {\n            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));\n        }\n    }\n    _next(value) {\n        if (!this.absoluteTimeout) {\n            this.scheduleTimeout();\n        }\n        super._next(value);\n    }\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _unsubscribe() {\n        this.action = null;\n        this.scheduler = null;\n        this.withObservable = null;\n    }\n}\n//# sourceMappingURL=timeoutWith.js.map"]},"metadata":{},"sourceType":"module"}