{"ast":null,"code":"import _get from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _classCallCheck from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { SubjectSubscriber } from '../Subject';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\n/**\n * @class ConnectableObservable<T>\n */\n\nexport var ConnectableObservable = /*#__PURE__*/function (_Observable) {\n  _inherits(ConnectableObservable, _Observable);\n\n  var _super = _createSuper(ConnectableObservable);\n\n  function ConnectableObservable(source, subjectFactory) {\n    var _this;\n\n    _classCallCheck(this, ConnectableObservable);\n\n    _this = _super.call(this);\n    _this.source = source;\n    _this.subjectFactory = subjectFactory;\n    _this._refCount = 0;\n    /** @internal */\n\n    _this._isComplete = false;\n    return _this;\n  }\n  /** @deprecated This is an internal implementation detail, do not use. */\n\n\n  _createClass(ConnectableObservable, [{\n    key: \"_subscribe\",\n    value: function _subscribe(subscriber) {\n      return this.getSubject().subscribe(subscriber);\n    }\n  }, {\n    key: \"getSubject\",\n    value: function getSubject() {\n      var subject = this._subject;\n\n      if (!subject || subject.isStopped) {\n        this._subject = this.subjectFactory();\n      }\n\n      return this._subject;\n    }\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      var connection = this._connection;\n\n      if (!connection) {\n        this._isComplete = false;\n        connection = this._connection = new Subscription();\n        connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n\n        if (connection.closed) {\n          this._connection = null;\n          connection = Subscription.EMPTY;\n        } else {\n          this._connection = connection;\n        }\n      }\n\n      return connection;\n    }\n  }, {\n    key: \"refCount\",\n    value: function refCount() {\n      return higherOrderRefCount()(this);\n    }\n  }]);\n\n  return ConnectableObservable;\n}(Observable);\nvar connectableProto = ConnectableObservable.prototype;\nexport var connectableObservableDescriptor = {\n  operator: {\n    value: null\n  },\n  _refCount: {\n    value: 0,\n    writable: true\n  },\n  _subject: {\n    value: null,\n    writable: true\n  },\n  _connection: {\n    value: null,\n    writable: true\n  },\n  _subscribe: {\n    value: connectableProto._subscribe\n  },\n  _isComplete: {\n    value: connectableProto._isComplete,\n    writable: true\n  },\n  getSubject: {\n    value: connectableProto.getSubject\n  },\n  connect: {\n    value: connectableProto.connect\n  },\n  refCount: {\n    value: connectableProto.refCount\n  }\n};\n\nvar ConnectableSubscriber = /*#__PURE__*/function (_SubjectSubscriber) {\n  _inherits(ConnectableSubscriber, _SubjectSubscriber);\n\n  var _super2 = _createSuper(ConnectableSubscriber);\n\n  function ConnectableSubscriber(destination, connectable) {\n    var _this2;\n\n    _classCallCheck(this, ConnectableSubscriber);\n\n    _this2 = _super2.call(this, destination);\n    _this2.connectable = connectable;\n    return _this2;\n  }\n\n  _createClass(ConnectableSubscriber, [{\n    key: \"_error\",\n    value: function _error(err) {\n      this._unsubscribe();\n\n      _get(_getPrototypeOf(ConnectableSubscriber.prototype), \"_error\", this).call(this, err);\n    }\n  }, {\n    key: \"_complete\",\n    value: function _complete() {\n      this.connectable._isComplete = true;\n\n      this._unsubscribe();\n\n      _get(_getPrototypeOf(ConnectableSubscriber.prototype), \"_complete\", this).call(this);\n    }\n  }, {\n    key: \"_unsubscribe\",\n    value: function _unsubscribe() {\n      var connectable = this.connectable;\n\n      if (connectable) {\n        this.connectable = null;\n        var connection = connectable._connection;\n        connectable._refCount = 0;\n        connectable._subject = null;\n        connectable._connection = null;\n\n        if (connection) {\n          connection.unsubscribe();\n        }\n      }\n    }\n  }]);\n\n  return ConnectableSubscriber;\n}(SubjectSubscriber);\n\nvar RefCountOperator = /*#__PURE__*/function () {\n  function RefCountOperator(connectable) {\n    _classCallCheck(this, RefCountOperator);\n\n    this.connectable = connectable;\n  }\n\n  _createClass(RefCountOperator, [{\n    key: \"call\",\n    value: function call(subscriber, source) {\n      var connectable = this.connectable;\n      connectable._refCount++;\n      var refCounter = new RefCountSubscriber(subscriber, connectable);\n      var subscription = source.subscribe(refCounter);\n\n      if (!refCounter.closed) {\n        refCounter.connection = connectable.connect();\n      }\n\n      return subscription;\n    }\n  }]);\n\n  return RefCountOperator;\n}();\n\nvar RefCountSubscriber = /*#__PURE__*/function (_Subscriber) {\n  _inherits(RefCountSubscriber, _Subscriber);\n\n  var _super3 = _createSuper(RefCountSubscriber);\n\n  function RefCountSubscriber(destination, connectable) {\n    var _this3;\n\n    _classCallCheck(this, RefCountSubscriber);\n\n    _this3 = _super3.call(this, destination);\n    _this3.connectable = connectable;\n    return _this3;\n  }\n\n  _createClass(RefCountSubscriber, [{\n    key: \"_unsubscribe\",\n    value: function _unsubscribe() {\n      var connectable = this.connectable;\n\n      if (!connectable) {\n        this.connection = null;\n        return;\n      }\n\n      this.connectable = null;\n      var refCount = connectable._refCount;\n\n      if (refCount <= 0) {\n        this.connection = null;\n        return;\n      }\n\n      connectable._refCount = refCount - 1;\n\n      if (refCount > 1) {\n        this.connection = null;\n        return;\n      } ///\n      // Compare the local RefCountSubscriber's connection Subscription to the\n      // connection Subscription on the shared ConnectableObservable. In cases\n      // where the ConnectableObservable source synchronously emits values, and\n      // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n      // execution continues to here before the RefCountOperator has a chance to\n      // supply the RefCountSubscriber with the shared connection Subscription.\n      // For example:\n      // ```\n      // Observable.range(0, 10)\n      //   .publish()\n      //   .refCount()\n      //   .take(5)\n      //   .subscribe();\n      // ```\n      // In order to account for this case, RefCountSubscriber should only dispose\n      // the ConnectableObservable's shared connection Subscription if the\n      // connection Subscription exists, *and* either:\n      //   a. RefCountSubscriber doesn't have a reference to the shared connection\n      //      Subscription yet, or,\n      //   b. RefCountSubscriber's connection Subscription reference is identical\n      //      to the shared connection Subscription\n      ///\n\n\n      var connection = this.connection;\n      var sharedConnection = connectable._connection;\n      this.connection = null;\n\n      if (sharedConnection && (!connection || sharedConnection === connection)) {\n        sharedConnection.unsubscribe();\n      }\n    }\n  }]);\n\n  return RefCountSubscriber;\n}(Subscriber);","map":{"version":3,"sources":["../../../src/internal/observable/ConnectableObservable.ts"],"names":[],"mappings":"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","sourcesContent":["import { SubjectSubscriber } from '../Subject';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\n/**\n * @class ConnectableObservable<T>\n */\nexport class ConnectableObservable extends Observable {\n    constructor(source, subjectFactory) {\n        super();\n        this.source = source;\n        this.subjectFactory = subjectFactory;\n        this._refCount = 0;\n        /** @internal */\n        this._isComplete = false;\n    }\n    /** @deprecated This is an internal implementation detail, do not use. */\n    _subscribe(subscriber) {\n        return this.getSubject().subscribe(subscriber);\n    }\n    getSubject() {\n        const subject = this._subject;\n        if (!subject || subject.isStopped) {\n            this._subject = this.subjectFactory();\n        }\n        return this._subject;\n    }\n    connect() {\n        let connection = this._connection;\n        if (!connection) {\n            this._isComplete = false;\n            connection = this._connection = new Subscription();\n            connection.add(this.source\n                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n            if (connection.closed) {\n                this._connection = null;\n                connection = Subscription.EMPTY;\n            }\n            else {\n                this._connection = connection;\n            }\n        }\n        return connection;\n    }\n    refCount() {\n        return higherOrderRefCount()(this);\n    }\n}\nconst connectableProto = ConnectableObservable.prototype;\nexport const connectableObservableDescriptor = {\n    operator: { value: null },\n    _refCount: { value: 0, writable: true },\n    _subject: { value: null, writable: true },\n    _connection: { value: null, writable: true },\n    _subscribe: { value: connectableProto._subscribe },\n    _isComplete: { value: connectableProto._isComplete, writable: true },\n    getSubject: { value: connectableProto.getSubject },\n    connect: { value: connectableProto.connect },\n    refCount: { value: connectableProto.refCount }\n};\nclass ConnectableSubscriber extends SubjectSubscriber {\n    constructor(destination, connectable) {\n        super(destination);\n        this.connectable = connectable;\n    }\n    _error(err) {\n        this._unsubscribe();\n        super._error(err);\n    }\n    _complete() {\n        this.connectable._isComplete = true;\n        this._unsubscribe();\n        super._complete();\n    }\n    _unsubscribe() {\n        const connectable = this.connectable;\n        if (connectable) {\n            this.connectable = null;\n            const connection = connectable._connection;\n            connectable._refCount = 0;\n            connectable._subject = null;\n            connectable._connection = null;\n            if (connection) {\n                connection.unsubscribe();\n            }\n        }\n    }\n}\nclass RefCountOperator {\n    constructor(connectable) {\n        this.connectable = connectable;\n    }\n    call(subscriber, source) {\n        const { connectable } = this;\n        connectable._refCount++;\n        const refCounter = new RefCountSubscriber(subscriber, connectable);\n        const subscription = source.subscribe(refCounter);\n        if (!refCounter.closed) {\n            refCounter.connection = connectable.connect();\n        }\n        return subscription;\n    }\n}\nclass RefCountSubscriber extends Subscriber {\n    constructor(destination, connectable) {\n        super(destination);\n        this.connectable = connectable;\n    }\n    _unsubscribe() {\n        const { connectable } = this;\n        if (!connectable) {\n            this.connection = null;\n            return;\n        }\n        this.connectable = null;\n        const refCount = connectable._refCount;\n        if (refCount <= 0) {\n            this.connection = null;\n            return;\n        }\n        connectable._refCount = refCount - 1;\n        if (refCount > 1) {\n            this.connection = null;\n            return;\n        }\n        ///\n        // Compare the local RefCountSubscriber's connection Subscription to the\n        // connection Subscription on the shared ConnectableObservable. In cases\n        // where the ConnectableObservable source synchronously emits values, and\n        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n        // execution continues to here before the RefCountOperator has a chance to\n        // supply the RefCountSubscriber with the shared connection Subscription.\n        // For example:\n        // ```\n        // Observable.range(0, 10)\n        //   .publish()\n        //   .refCount()\n        //   .take(5)\n        //   .subscribe();\n        // ```\n        // In order to account for this case, RefCountSubscriber should only dispose\n        // the ConnectableObservable's shared connection Subscription if the\n        // connection Subscription exists, *and* either:\n        //   a. RefCountSubscriber doesn't have a reference to the shared connection\n        //      Subscription yet, or,\n        //   b. RefCountSubscriber's connection Subscription reference is identical\n        //      to the shared connection Subscription\n        ///\n        const { connection } = this;\n        const sharedConnection = connectable._connection;\n        this.connection = null;\n        if (sharedConnection && (!connection || sharedConnection === connection)) {\n            sharedConnection.unsubscribe();\n        }\n    }\n}\n//# sourceMappingURL=ConnectableObservable.js.map"]},"metadata":{},"sourceType":"module"}