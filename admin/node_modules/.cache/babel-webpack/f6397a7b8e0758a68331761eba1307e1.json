{"ast":null,"code":"import _get from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n *\n * <img src=\"./img/catch.png\" width=\"100%\">\n *\n * @example <caption>Continues with a different Observable when there's an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n == 4) {\n * \t     throw 'four!';\n *     }\n *\t   return n;\n *   })\n *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, I, II, III, IV, V\n *\n * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n === 4) {\n * \t     throw 'four!';\n *     }\n * \t   return n;\n *   })\n *   .catch((err, caught) => caught)\n *   .take(30)\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, 1, 2, 3, ...\n *\n * @example <caption>Throws a new error when the source Observable throws an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n *     if (n == 4) {\n *       throw 'four!';\n *     }\n *     return n;\n *   })\n *   .catch(err => {\n *     throw 'error in source. Details: ' + err;\n *   })\n *   .subscribe(\n *     x => console.log(x),\n *     err => console.log(err)\n *   );\n *   // 1, 2, 3, error in source. Details: four!\n *\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n *  is returned by the `selector` will be used to continue the observable chain.\n * @return {Observable} An observable that originates from either the source or the observable returned by the\n *  catch `selector` function.\n * @name catchError\n */\n\nexport function catchError(selector) {\n  return function catchErrorOperatorFunction(source) {\n    var operator = new CatchOperator(selector);\n    var caught = source.lift(operator);\n    return operator.caught = caught;\n  };\n}\n\nvar CatchOperator = /*#__PURE__*/function () {\n  function CatchOperator(selector) {\n    _classCallCheck(this, CatchOperator);\n\n    this.selector = selector;\n  }\n\n  _createClass(CatchOperator, [{\n    key: \"call\",\n    value: function call(subscriber, source) {\n      return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));\n    }\n  }]);\n\n  return CatchOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar CatchSubscriber = /*#__PURE__*/function (_OuterSubscriber) {\n  _inherits(CatchSubscriber, _OuterSubscriber);\n\n  var _super = _createSuper(CatchSubscriber);\n\n  function CatchSubscriber(destination, selector, caught) {\n    var _this;\n\n    _classCallCheck(this, CatchSubscriber);\n\n    _this = _super.call(this, destination);\n    _this.selector = selector;\n    _this.caught = caught;\n    return _this;\n  } // NOTE: overriding `error` instead of `_error` because we don't want\n  // to have this flag this subscriber as `isStopped`. We can mimic the\n  // behavior of the RetrySubscriber (from the `retry` operator), where\n  // we unsubscribe from our source chain, reset our Subscriber flags,\n  // then subscribe to the selector result.\n\n\n  _createClass(CatchSubscriber, [{\n    key: \"error\",\n    value: function error(err) {\n      if (!this.isStopped) {\n        var result;\n\n        try {\n          result = this.selector(err, this.caught);\n        } catch (err2) {\n          _get(_getPrototypeOf(CatchSubscriber.prototype), \"error\", this).call(this, err2);\n\n          return;\n        }\n\n        this._unsubscribeAndRecycle();\n\n        this.add(subscribeToResult(this, result));\n      }\n    }\n  }]);\n\n  return CatchSubscriber;\n}(OuterSubscriber);","map":{"version":3,"sources":["../../../src/internal/operators/catchError.ts"],"names":[],"mappings":";;;;;;AAIA,SAAS,eAAT,QAAgC,oBAAhC;AACA,SAAS,iBAAT,QAAkC,2BAAlC;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyDA,OAAM,SAAA,UAAA,CAA2B,QAA3B,EAA4F;AAChG,SAAO,SAAA,0BAAA,CAAoC,MAApC,EAAyD;AAC9D,QAAM,QAAQ,GAAG,IAAI,aAAJ,CAAkB,QAAlB,CAAjB;AACA,QAAM,MAAM,GAAG,MAAM,CAAC,IAAP,CAAY,QAAZ,CAAf;AACA,WAAQ,QAAQ,CAAC,MAAT,GAAkB,MAA1B;AACD,GAJD;AAKD;;IAED,a;AAGE,yBAAoB,QAApB,EAAyF;AAAA;;AAArE,SAAA,QAAA,GAAA,QAAA;AACnB;;;;yBAEI,U,EAA2B,M,EAAW;AACzC,aAAO,MAAM,CAAC,SAAP,CAAiB,IAAI,eAAJ,CAAoB,UAApB,EAAgC,KAAK,QAArC,EAA+C,KAAK,MAApD,CAAjB,CAAP;AACD;;;;;AAGH;;;;;;;IAKA,e;;;;;AACE,2BAAY,WAAZ,EACoB,QADpB,EAEoB,MAFpB,EAEyC;AAAA;;AAAA;;AACvC,8BAAM,WAAN;AAFkB,UAAA,QAAA,GAAA,QAAA;AACA,UAAA,MAAA,GAAA,MAAA;AAAqB;AAExC,G,CAED;AACA;AACA;AACA;AACA;;;;;0BACM,G,EAAQ;AACZ,UAAI,CAAC,KAAK,SAAV,EAAqB;AACnB,YAAI,MAAJ;;AACA,YAAI;AACF,UAAA,MAAM,GAAG,KAAK,QAAL,CAAc,GAAd,EAAmB,KAAK,MAAxB,CAAT;AACD,SAFD,CAEE,OAAO,IAAP,EAAa;AACb,qFAAY,IAAZ;;AACA;AACD;;AACD,aAAK,sBAAL;;AACA,aAAK,GAAL,CAAS,iBAAiB,CAAC,IAAD,EAAO,MAAP,CAA1B;AACD;AACF;;;;EAxBiC,e","sourcesContent":["import { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n *\n * <img src=\"./img/catch.png\" width=\"100%\">\n *\n * @example <caption>Continues with a different Observable when there's an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n == 4) {\n * \t     throw 'four!';\n *     }\n *\t   return n;\n *   })\n *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, I, II, III, IV, V\n *\n * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n * \t   if (n === 4) {\n * \t     throw 'four!';\n *     }\n * \t   return n;\n *   })\n *   .catch((err, caught) => caught)\n *   .take(30)\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, 1, 2, 3, ...\n *\n * @example <caption>Throws a new error when the source Observable throws an error</caption>\n *\n * Observable.of(1, 2, 3, 4, 5)\n *   .map(n => {\n *     if (n == 4) {\n *       throw 'four!';\n *     }\n *     return n;\n *   })\n *   .catch(err => {\n *     throw 'error in source. Details: ' + err;\n *   })\n *   .subscribe(\n *     x => console.log(x),\n *     err => console.log(err)\n *   );\n *   // 1, 2, 3, error in source. Details: four!\n *\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n *  is returned by the `selector` will be used to continue the observable chain.\n * @return {Observable} An observable that originates from either the source or the observable returned by the\n *  catch `selector` function.\n * @name catchError\n */\nexport function catchError(selector) {\n    return function catchErrorOperatorFunction(source) {\n        const operator = new CatchOperator(selector);\n        const caught = source.lift(operator);\n        return (operator.caught = caught);\n    };\n}\nclass CatchOperator {\n    constructor(selector) {\n        this.selector = selector;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));\n    }\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass CatchSubscriber extends OuterSubscriber {\n    constructor(destination, selector, caught) {\n        super(destination);\n        this.selector = selector;\n        this.caught = caught;\n    }\n    // NOTE: overriding `error` instead of `_error` because we don't want\n    // to have this flag this subscriber as `isStopped`. We can mimic the\n    // behavior of the RetrySubscriber (from the `retry` operator), where\n    // we unsubscribe from our source chain, reset our Subscriber flags,\n    // then subscribe to the selector result.\n    error(err) {\n        if (!this.isStopped) {\n            let result;\n            try {\n                result = this.selector(err, this.caught);\n            }\n            catch (err2) {\n                super.error(err2);\n                return;\n            }\n            this._unsubscribeAndRecycle();\n            this.add(subscribeToResult(this, result));\n        }\n    }\n}\n//# sourceMappingURL=catchError.js.map"]},"metadata":{},"sourceType":"module"}