{"ast":null,"code":"import _toConsumableArray from \"C:/xampp/htdocs/admin/admin/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { Observable } from '../Observable';\nimport { from } from './from';\nimport { isArray } from '../util/isArray';\nimport { EMPTY } from './empty';\n/* tslint:enable:max-line-length */\n\n/**\n * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\n * that was passed.\n *\n * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\n *\n * <img src=\"./img/onErrorResumeNext.png\" width=\"100%\">\n *\n * `onErrorResumeNext` Will subscribe to each observable source it is provided, in order.\n * If the source it's subscribed to emits an error or completes, it will move to the next source\n * without error.\n *\n * If `onErrorResumeNext` is provided no arguments, or a single, empty array, it will return {@link EMPTY}.\n *\n * `onErrorResumeNext` is basically {@link concat}, only it will continue, even if one of its\n * sources emits an error.\n *\n * Note that there is no way to handle any errors thrown by sources via the resuult of\n * `onErrorResumeNext`. If you want to handle errors thrown in any given source, you can\n * always use the {@link catchError} operator on them before passing them into `onErrorResumeNext`.\n *\n * @example <caption>Subscribe to the next Observable after map fails</caption>\n * import { onErrorResumeNext, of } from 'rxjs/create';\n * import { map } from 'rxjs/operators';\n *\n * onErrorResumeNext(\n *  of(1, 2, 3, 0).pipe(\n *    map(x => {\n *      if (x === 0) throw Error();\n *      return 10 / x;\n *    })\n *  ),\n *  of(1, 2, 3),\n * )\n * .subscribe(\n *   val => console.log(val),\n *   err => console.log(err),          // Will never be called.\n *   () => console.log('done')\n * );\n *\n * // Logs:\n * // 10\n * // 5\n * // 3.3333333333333335\n * // 1\n * // 2\n * // 3\n * // \"done\"\n *\n * @see {@link concat}\n * @see {@link catch}\n *\n * @param {...ObservableInput} sources Observables (or anything that *is* observable) passed either directly or as an array.\n * @return {Observable} An Observable that concatenates all sources, one after the other,\n * ignoring all errors, such that any error causes it to move on to the next source.\n */\n\nexport function onErrorResumeNext() {\n  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n    sources[_key] = arguments[_key];\n  }\n\n  if (sources.length === 0) {\n    return EMPTY;\n  }\n\n  var first = sources[0],\n      remainder = sources.slice(1);\n\n  if (sources.length === 1 && isArray(first)) {\n    return onErrorResumeNext.apply(void 0, _toConsumableArray(first));\n  }\n\n  return new Observable(function (subscriber) {\n    var subNext = function subNext() {\n      return subscriber.add(onErrorResumeNext.apply(void 0, _toConsumableArray(remainder)).subscribe(subscriber));\n    };\n\n    return from(first).subscribe({\n      next: function next(value) {\n        subscriber.next(value);\n      },\n      error: subNext,\n      complete: subNext\n    });\n  });\n}","map":{"version":3,"sources":["../../../src/internal/observable/onErrorResumeNext.ts"],"names":[],"mappings":";AAAA,SAAS,UAAT,QAA2B,eAA3B;AAEA,SAAS,IAAT,QAAqB,QAArB;AACA,SAAS,OAAT,QAAwB,iBAAxB;AACA,SAAS,KAAT,QAAsB,SAAtB;AAWA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwDA,OAAM,SAAA,iBAAA,GAEuF;AAAA,oCAFlD,OAEkD;AAFlD,IAAA,OAEkD;AAAA;;AAE3F,MAAI,OAAO,CAAC,MAAR,KAAmB,CAAvB,EAA0B;AACxB,WAAO,KAAP;AACD;;AAJ0F,MAMnF,KANmF,GAM3D,OAN2D;AAAA,MAMzE,SANyE,GAM3D,OAN2D;;AAQ3F,MAAI,OAAO,CAAC,MAAR,KAAmB,CAAnB,IAAwB,OAAO,CAAC,KAAD,CAAnC,EAA4C;AAC1C,WAAO,iBAAiB,MAAjB,4BAAqB,KAArB,EAAP;AACD;;AAED,SAAO,IAAI,UAAJ,CAAe,UAAA,UAAU,EAAG;AACjC,QAAM,OAAO,GAAG,SAAV,OAAU;AAAA,aAAM,UAAU,CAAC,GAAX,CACpB,iBAAiB,MAAjB,4BAAqB,SAArB,GAAgC,SAAhC,CAA0C,UAA1C,CADoB,CAAN;AAAA,KAAhB;;AAIA,WAAO,IAAI,CAAC,KAAD,CAAJ,CAAY,SAAZ,CAAsB;AAC3B,MAAA,IAD2B,gBACtB,KADsB,EACjB;AAAI,QAAA,UAAU,CAAC,IAAX,CAAgB,KAAhB;AAAyB,OADZ;AAE3B,MAAA,KAAK,EAAE,OAFoB;AAG3B,MAAA,QAAQ,EAAE;AAHiB,KAAtB,CAAP;AAKD,GAVM,CAAP;AAWD","sourcesContent":["import { Observable } from '../Observable';\nimport { from } from './from';\nimport { isArray } from '../util/isArray';\nimport { EMPTY } from './empty';\n/* tslint:enable:max-line-length */\n/**\n * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\n * that was passed.\n *\n * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\n *\n * <img src=\"./img/onErrorResumeNext.png\" width=\"100%\">\n *\n * `onErrorResumeNext` Will subscribe to each observable source it is provided, in order.\n * If the source it's subscribed to emits an error or completes, it will move to the next source\n * without error.\n *\n * If `onErrorResumeNext` is provided no arguments, or a single, empty array, it will return {@link EMPTY}.\n *\n * `onErrorResumeNext` is basically {@link concat}, only it will continue, even if one of its\n * sources emits an error.\n *\n * Note that there is no way to handle any errors thrown by sources via the resuult of\n * `onErrorResumeNext`. If you want to handle errors thrown in any given source, you can\n * always use the {@link catchError} operator on them before passing them into `onErrorResumeNext`.\n *\n * @example <caption>Subscribe to the next Observable after map fails</caption>\n * import { onErrorResumeNext, of } from 'rxjs/create';\n * import { map } from 'rxjs/operators';\n *\n * onErrorResumeNext(\n *  of(1, 2, 3, 0).pipe(\n *    map(x => {\n *      if (x === 0) throw Error();\n *      return 10 / x;\n *    })\n *  ),\n *  of(1, 2, 3),\n * )\n * .subscribe(\n *   val => console.log(val),\n *   err => console.log(err),          // Will never be called.\n *   () => console.log('done')\n * );\n *\n * // Logs:\n * // 10\n * // 5\n * // 3.3333333333333335\n * // 1\n * // 2\n * // 3\n * // \"done\"\n *\n * @see {@link concat}\n * @see {@link catch}\n *\n * @param {...ObservableInput} sources Observables (or anything that *is* observable) passed either directly or as an array.\n * @return {Observable} An Observable that concatenates all sources, one after the other,\n * ignoring all errors, such that any error causes it to move on to the next source.\n */\nexport function onErrorResumeNext(...sources) {\n    if (sources.length === 0) {\n        return EMPTY;\n    }\n    const [first, ...remainder] = sources;\n    if (sources.length === 1 && isArray(first)) {\n        return onErrorResumeNext(...first);\n    }\n    return new Observable(subscriber => {\n        const subNext = () => subscriber.add(onErrorResumeNext(...remainder).subscribe(subscriber));\n        return from(first).subscribe({\n            next(value) { subscriber.next(value); },\n            error: subNext,\n            complete: subNext,\n        });\n    });\n}\n//# sourceMappingURL=onErrorResumeNext.js.map"]},"metadata":{},"sourceType":"module"}